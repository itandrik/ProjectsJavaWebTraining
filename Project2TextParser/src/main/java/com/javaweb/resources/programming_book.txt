Preface
Anyone involved with the open source community or using open source software knows there are tons
of tools available on the market. Keeping up with these tools, and knowing which tools to use and
how to use them, is an intimidating road to travel. We hope to simplify your journey by showing
concise, useful recipes for some of the more popular open source Java tools on the market today.
We show you tools like JUnit, JUnitPerf, Mock Objects (more of a concept), and Cactus for testing
Java code. We show how to generate EJB files using XDoclet, too. All tools discussed in this book are
completely executable through Ant, allowing for a complete and stable build environment on any
Java-enabled platform.
This is also a book about Extreme Programming (XP), which led us to choose the tools that we did.
The XP software development approach does not depend on a particular set of tools; however, the
right tools certainly make following XP practices easier. For instance, test-first development is a
cornerstone of XP, so most of the tools in this book are testing frameworks. XP also demands
continuous integration, which is where Ant fits in. We are big fans of automation, so we cover the
XDoclet code generator as well as describe ways to automate deployment to Tomcat and JBoss.
Audience
This book is for Java programmers who are interested in creating a stable, efficient, and testable
development environment using open source tools. We do not assume any prior knowledge of XP or
the tools covered in this book, although we do assume that you know Java. The chapters generally
open with simple recipes and progress to more advanced topics.
About the Recipes
This book is a collection of solutions and discussions to real-world Java programming problems. The
recipes include topics such as writing JUnit tests, packaging and deploying server-side tests to
application servers, and generating custom code using XDoclet. Each recipe follows the same format.
A problem and brief solution is presented, followed by in-depth discussion.
You can find the code online at http://www.oreilly.com/catalog/jextprockbk/.
Organization
This book consists of 11 chapters, as follows:
Chapter 1
This chapter provides a quick overview of each tool covered in this book. It also explains how
the tool selection relates to XP.
Chapter 2
This chapter explains many key concepts of XP.
Chapter 3
This chapter is a beginner's overview to Ant, a portable Java alternative to make utilities.
Chapter 4
This chapter provides in-depth coverage of JUnit, the most popular testing framework
available for Java.
Chapter 5
This chapter shows how to use HttpUnit for testing web applications.
Chapter 6
This chapter explains techniques for using mock objects for advanced testing.
Chapter 7
This chapter describes how to test servlets, filters, and JSPs running in a servlet container.
This is the only tool in this book devoted to in-container testing (tests that execute in a
running server).
Chapter 8
This chapter shows how to use JUnitPerf, a simple and effective tool for writing performance
tests around existing JUnit tests. This chapter also discusses how to use JUnitPerfDoclet,
which is a custom XDoclet code generator created specifically for this book.
Chapter 9
This chapter shows how to use the XDoclet code generator. In addition to showing how to
generate EJB code, we show how to create a custom code generator from the ground up. This
code generator is used to generate JUnitPerf tests and is aptly name JUnitPerfDoclet.
Chapter 10
This chapter shows how to incorporate Tomcat and JBoss into an XP build environment.
Tomcat is the official reference implementation of the servlet specification and JBoss is
arguably the most popular open source EJB container.
Chapter 11
This chapter introduces additional open source tools that are gaining popularity but were not
quite ready for their own chapters.
Conventions Used in This Book
The following typographical conventions are used in this book:
Italic
Used for Unix and Windows commands, filenames and directory names, emphasis, and first
use of a technical term.
Constant width
Used in code examples and to show the contents of files. Also used for Java class names, Ant
task names, tags, attributes, and environment variable names appearing in the text.
Constant width italic
Used as a placeholder to indicate an item that should be replaced with an actual value in your
program.
Constant width bold
Used for user input in text and in examples showing both input and output.
Comments and Questions
Please address comments and questions concerning this book to the publisher:
O'Reilly & Associates, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
(800) 998-9938 (in the United States or Canada)
(707) 829-0515 (international/local)
(707) 829-0104 (fax)
There is a web page for this book, which lists errata, examples, or any additional information. You can
access this page at:
http://www.oreilly.com/catalog/jextprockbk/
To comment or ask technical questions about this book, send email to:
bookquestions@oreilly.com
For information about books, conferences, Resource Centers, and the O'Reilly Network, see the
O'Reilly web site at:
http://www.oreilly.com
Acknowledgments
This is my third book, and I find myself consistently underestimating how much time it takes to write
these things. I have to extend a big thanks to Brian for helping bring this book to completion. Without
his help, I don't think I could have done this.
My family is the most important part of my life, and I want to thank Jennifer, Aidan, and Tanner for
supporting and inspiring me, even though I spend way too many hours working. I love you all.
—Eric Burke, December 2002
I would like to thank Eric for bringing me on board to write this book. Without his support and trust, I
would not have received this wonderful opportunity.
My Mom and Dad have provided years of support and encouragement. I appreciate everything you
have done for me, and I love you both very much. Without you I would not be where I am today.
And Grandpa, you are in my heart and prayers every day. You would be so proud. I wish you were
here to see this.
—Brian Coyner, December 2002
We both want to thank our editor, Mike Loukides, for helping mold this book into reality. An infinite
amount of thanks goes to the tech reviewers: Kyle Cordes, Kevin Stanley, Bob Lee, Brian Button,
Mark Volkmann, Mario Aquino, Mike Clark, Ara Abrahamian, and Derek Lane.
Chapter 1. XP Tools
This is a book about open source Java tools that complement Extreme Programming (XP) practices. In
this chapter, we outline the relationship between programming tools and XP, followed by a brief
introduction to the tools covered in this book. Our approach to tool selection and software
development revolves around three key concepts: automation, regression testing, and consistency
among developers. First, let's explain how tools relate to XP.
1.1 Java and XP
XP is a set of principles and practices that guide software development. It is an agile process in that it
makes every effort to eliminate unnecessary work, instead focusing on tasks that deliver value to the
customer.[1] XP is built upon four principles: simplicity, communication, feedback, and courage, all
described in Chapter 2. The four XP principles have nothing to do with programming languages and
tools. Although this book shows a set of Java tools that work nicely with XP, you are not limited to
Java and these tools. XP is a language-independent software development approach.
[1] Check out http://www.agilealliance.com to learn more about agile processes.
While XP works with any language, we believe it works well with Java for a few reasons. Most
important is the speed with which Java compiles. XP relies on test-first development in which
programmers write tests for code before they write the code. For each new feature, you should write a
test and then watch the test run and fail. You should then add the feature, compile, and watch the test
run successfully. This implies that you must write a little code, compile, and run the tests frequently,
perhaps dozens of times each day. Because Java compiles quickly, it is well suited to the test-first
approach.
The second reason Java is a good choice for XP development is Java's wealth of tools supporting unit
testing and continuous integration. JUnit, covered in Chapter 4, provides a lightweight framework for
writing automated unit tests. Ant, the premier build tool for Java, makes continuous integration
possible even when working with large development teams. You will also find more specialized
testing tools such as Cactus and HttpUnit for server-side testing.
Java's power and simplicity also make it a good language when writing code using XP. Many features
of the tools outlined in this book, such as Ant tasks and JUnit's test suites, are built upon Java's
reflection capability. Java's relatively easy syntax makes it easier to maintain code written by other
team members, which is important for XP's concepts of pair programming, refactoring, and collective
code ownership.
1.2 Tools and Philosophies
Creating great software is an art. If you ask a dozen programmers to solve a particular problem, you
are likely to get a dozen radically different solutions. If you observe how these programmers reach
their solutions, you will note that each programmer has her own favorite set of tools. One programmer
may start by designing the application architecture using a UML CASE tool. Another may use wizards
included with a fancy IDE, while another is perfectly content to use Emacs or vi.
Differences in opinion also manifest themselves at the team and company level. Some companies feel
most comfortable with enterprise class commercial tools, while others are perfectly happy to build
their development environment using a variety of open source tools. XP works regardless of which
tools you choose, provided that your tools support continuous integration and automated unit testing.
These concepts are detailed in the next chapter.
We are very skeptical of the term "enterprise class." This tends to be a
marketing ploy, and actually means "the features you really need," such as
integrated support for free tools like JUnit, Ant, and CVS.
1.2.1 The IDE Philosophy
Many commercial IDEs focus very heavily on graphical "wizards" that help you automatically
generate code, hide complexity from beginners, and deploy to application servers. If you choose such
a tool, make sure it also allows for command-line operation so you can support continuous integration
and automated unit testing. If you are forced to use the graphical wizards, you will be locked into that
vendor's product and unable to automate your processes. We strongly recommend XDoclet, Covered
in Chapter 9, for automated code generation. This is a free alternative to wizard-based code generation
and does not lock you into a particular vendor's product.[2]
[2] XDoclet allows you to generate any kind of code and thus works with any application server.
This book does not cover commercial development environments and tools. Instead, we show how
you can use free tools to build your own development environment and support XP practices. Perhaps
in a sign of things to come, more and more commercial development environments now provide direct
support for the open source tools covered in this book. With free IDEs like Eclipse and Netbeans
growing in popularity and functionality, you will soon be hard-pressed to justify spending thousands
of dollars per developer for functionality you can get for free.[3]
[3] Both authors use IntelliJ IDEA, a commercial IDE available at http://www.intellij.com. Although it costs
around $400, we feel its refactoring support easily adds enough productivity to justify the cost.
1.2.2 Minimum Tool Requirements
Regardless of whether you choose to use open source or commercial tools, XP works most effectively
when your tool selection supports the concepts mentioned at the beginning of this chapter. These three
concepts are automation, regression testing, and consistency among developers.
1.2.2.1 Automation
XP requires automation. In an XP project, programmers are constantly pairing up with one another
and working on code from any given part of the application. The system is coded in small steps, with
many builds occurring each day. You simply cannot be successful if each programmer must remember
a series of manual steps in order to compile, deploy, and test different parts of the application.
People often talk about "one-button testing" in XP, meaning that you should be able to click a single
button—or type a simple command like ant junit—in order to compile everything, deploy to the
app server, and run all tests.
Automation also applies to repetitive, mundane coding tasks. You increase your chances of success by
identifying repeating patterns and then writing or using tools to automatically generate code.
Automation reduces chances for human error and makes coding more enjoyable because you don't
have to spend so much time on the boring stuff.
1.2.2.2 Regression testing
Automated regression testing is the building block that makes XP possible, and we will spend a lot
more time talking about it in the next chapter. Testing, most notably unit testing, is tightly coupled
with an automated build process. In XP, each new feature is implemented along with a complementary
unit test. When bugs are encountered, a test is written to expose the bug before the bug is fixed. Once
the bug is fixed, the test passes.
Tools must make it easy for programmers to write and run tests. If tests require anything more than a
simple command to run, programmers will not run the tests as often as they should. JUnit makes it
easy to write basic unit tests, and more specialized testing frameworks make it possible to write tests
for web applications and other types of code. JUnit has been integrated with Ant for a long time, and
most recent IDEs make it easy to run JUnit tests by clicking on a menu and selecting "run tests."
1.2.2.3 Consistency among developers
In a true XP environment, developers are constantly shuffling from machine-to-machine, working
with new programming partners, and making changes to code throughout a system. To combat the
chaos that might otherwise occur, it is essential that tools make every developer's personal build
environment identical to other team members' environments. If Alex types ant junit and all tests
pass, Andy and Rachel should also expect all tests to run when they type the same command on their
own computers.
Providing a consistent environment seems obvious, but many IDEs do not support consistent
configuration across a team of developers. In many cases, each developer must build his own personal
project file. In this world it becomes very difficult to ensure that Andy and Rachel are using the same
versions of the various JAR files for a project. Andy may be using an older version of xalan.jar than
everyone else on the team. He may then commit changes that break the build for everyone else on the
team for a few hours while they figure out the root of the problem.
1.3 Open Source Toolkit
Open source tools have been with us for a long time, but did not always enjoy widespread acceptance
within the corporate environment. This has all changed in the past few years, as free tools became
increasingly powerful and popular. In many cases, open source tools have no commercial equivalent.
In others, commercial tools have embraced open source tools due to popular demand—although you
may have to purchase the most expensive enterprise edition to get these features. This is ironic
because Ant and JUnit are free.
In this section, we introduce the tools used throughout this book. While we have no reason to suggest
that you avoid commercial tools, we believe you can achieve the same end result without an expensive
investment in tools.
1.3.1 Version Control
Version control tools are an essential building block of any software development project, so much so
that we assume you are familiar with the basic concepts. We do not cover any specific tool in this
book; however, we do want to spend a few moments pointing out how tools like CVS fit into an XP
toolkit.
CVS keeps a master copy of each file on a shared directory or server, known as the repository. The
repository keeps a history of all changes to each file, allowing you to view a history of changes,
recover previous revisions of files, and mark particular revisions with tag names. In a nutshell, tools
like CVS allow an entire team to update and maintain files in a predictable, repeatable way.
Each programmer has a copy of the entire code base on his computer, and makes changes locally
without affecting other programmers. When the current task is complete, the programmer commits the
modified files back to the CVS repository. The newly revised files are then visible to other
programmers, who can choose to update to the new revisions whenever they are ready.
Regardless of whether you are using CVS or some other tool, two key principles always apply. These
principles are:
• Work in small steps.
• Stay in sync with the shared repository.
Because of the pair programming required by XP, working in small steps is a necessity. You cannot
switch programming partners several times per day if you work on tasks that take several days to
complete. A key to XP success is your ability to break down a project into smaller tasks that can be
completed within a few hours. Working in small steps also helps when using CVS (or any other
version control tool) because your personal workspace does not get too far out of sync with the
repository.
With CVS, multiple programmers on the team may work on the same files concurrently. When this
happens, you must merge changes and resolve conflicts before committing your modified code to the
repository. The best way to minimize potential for conflicts is to perform frequent updates. If a
programmer does not get the latest code for days and weeks at a time, she increases the likelihood of
conflict with work done by other team members.
While CVS allows concurrent edits to the same files, other version control tools force programmers to
lock files before making changes. While exclusive locking seems safer than concurrent editing, it can
impede development if other team members are unable to make changes. Again, working in small
steps is the best way to avoid problems when working with locking version control tools. If each
programmer only locks a few files at a time, the likelihood of lock contention is greatly reduced.
1.3.2 Ant
Ant, covered in Chapter 3, is a Java replacement for platform-specific make utilities. Instead of a
Makefile, Ant uses an XML buildfile typically named build.xml. This buildfile defines how source
code is compiled, JAR files are built, EAR files are deployed to servers, and unit tests are executed.
Ant controls all aspects of the software build process and guarantees that all developers have a
common baseline environment.
In the XP model, all programmers on the team share code. Programmers work in pairs that constantly
shuffle. XP shuns the idea of certain individuals owning different frameworks within a system.
Instead, any programmer is allowed to work on any piece of code in the application in order to finish
tasks. Shared code spreads knowledge and makes it easier for people to swap programming partners.
Sharing code also coerces people into writing tests, because those tests provide a safety net when
working in unfamiliar territory.
Ant is important to XP because you cannot afford to have each developer compiling different parts of
the system using different system configurations. Individual classpath settings might mean that code
compiles for one team member, but fails to compile for everyone else. Ant eliminates this class of
problem by defining a consistent build environment for all developers.
Ant buildfiles consist of targets and tasks. Targets define how developers use the buildfile, and tasks
perform the actual work, such as compiling code or running tests. You generally begin by writing a
basic Ant buildfile with the following targets:
prepare
Creates the output directories which will contain the generated .class files.
compile
Compiles all Java source code into the executable.
clean
Removes the build directory and all generated files, such as .class files.
junit
Searches for all unit tests in the directory structure and runs them. Tests are files following
the Test*.java naming convention.[4]
[4] You can adopt whatever naming convention you wish; we chose Test*.java for this book.
This is a good start, and will certainly be expanded upon later. A critical feature of this Ant buildfile is
the fact that it should define its own classpath internally. This way, individual developers'
environment variable settings do not cause unpredictable builds for other developers. You should add
the Ant buildfile to your version control tool and write a few simple classes to confirm that it runs
successfully.
The other developers on the team then get the Ant buildfile from the version control repository and
use it on their own computers. We also recommend that you place all required JAR files into version
control,[5] thus allowing the Ant buildfile to reference those JAR files from a standard location.
[5] You normally don't put generated code into CVS, but third-party JAR files are not generated by you.
Instead, they are resources required to build your software, just like source files.
1.3.3 JUnit
Automated unit testing is one of the most important facets of XP and a central theme throughout this
book. JUnit tests are written by programmers and are designed to test individual modules. They must
be designed to execute without human interaction. JUnit is not intended to be a complete framework
for all types of testing. In particular, JUnit is not well-suited for high-level integration testing.
Instead, JUnit is a programmer-level framework for writing unit tests in Java. Programmers extend
from the TestCase base class and write individual unit tests following a simple naming
convention. These tests are then organized into test suites and executed using a text or graphical test
runner.
JUnit is a simple framework for writing tests, and it is easily extended. In fact, JUnit is the starting
point for several of the other testing tools covered in this book. From one perspective, the JUnit API is
a framework for building other, more sophisticated testing frameworks and tools.
Tools like CVS, JUnit, and Ant become more powerful when everyone on the team uses them
consistently. You might want to talk to the other programmers on your team and come up with a set of
guidelines for adding new features to your application. The following list shows one such approach
for adding a new feature to a system:
1. Update your PC with the latest source files from the CVS repository. This minimizes the
chance of conflicts once you are finished.
2. Write a unit test using JUnit. Try to execute one facet of the new functionality that does not
yet exist. Or, write a test to expose a bug that you are trying to fix.
3. Run the test using JUnit and Ant by typing ant junit. The junit Ant target is defined
with a dependency on the compile target, so all code is automatically compiled.
4. After watching the test fail, write some code to make the test pass.
5. Run the test again by typing ant junit. Repeat steps 2-5 until the task is complete and all
tests pass. The task is complete when you have written tests for anything you think might
break and all tests pass.
6. Perform another CVS update to ensure you are up-to-date with all recent changes. This is a
critical step because the CVS repository may have changed while you were working on your
task.
7. Run ant clean junit in order to perform a full build.
8. If all code compiles and all tests pass, commit changes to CVS and move to the next task.
Otherwise, go back and fix whatever broke before committing changes to CVS.
It is important for every developer to follow these steps, because you are using XP and practicing pair
programming. Each of the team members takes turn pair programming with another person and each
of you is allowed to make changes to any part of the code. Because you are all constantly updating a
shared code base, you rely on the suite of automated unit tests along with a consistent build
environment to immediately catch errors.
Provided everyone follows the process, it is generally easy to fix problems when a test starts failing.
Because all tests passed before you made your changes, you can assume that the most recent change
broke the test. If you work in small steps, the problem is usually (but not always!) easy to fix.
On the other hand, things get really ugly when a programmer commits changes to CVS without first
running the tests. If that programmer's change broke a test, then all other programmers on the team
begin to see test failures. They assume that they broke the test, and waste time debugging their own
code. For a team of ten programmers, this may mean that ten programmers spend one hour each
tracking down the problem, only to find that it wasn't their fault in the first place. Had that first
programmer run the tests locally, he may have been able to fix the problem in a few minutes rather
than wasting ten hours.[6]
[6] If the shared code base breaks frequently, programmers may begin to ignore the errors. This causes a
snowball effect when they quit running tests and check in even more bad code. Pair programming helps
avoid these breakdowns in diligence.
1.3.4 HttpUnit and Cactus
HttpUnit, covered in Chapter 5, is a framework for testing web applications. HttpUnit isn't built with
JUnit; however, you do use JUnit when testing with HttpUnit. HttpUnit tests execute entirely on the
client machine and access a web server by sending HTTP requests. In this fashion, HttpUnit simulates
a web browser hitting a web site. Although you typically use JUnit when working with HttpUnit, the
tests you write are more correctly considered "functional" tests rather than "unit" tests. This is because
HttpUnit can only test a web application from the outside view, instead of unit-testing individual
classes and methods.
A closely related tool is Cactus, covered in Chapter 7. Cactus is significantly more complicated than
HttpUnit, and is built on top of JUnit. Cactus tests allow for true unit testing of web applications, with
specific types of tests for servlets, JSPs, and servlet filters. Unlike HttpUnit, Cactus tests execute on
both client and server—simultaneously. The client portion of the test acts something like a web
browser, issuing requests to the server portion of the test that acts more like a unit test. The server then
sends a response back to the client portion that then interprets the results.
Cactus can also make use of the HttpUnit library for parsing the HTML output from web applications.
We'll see how this works in Chapter 7.
1.3.5 JUnitPerf
JUnitPerf, as you might expect, is a performance-testing tool built on top of JUnit. In Chapter 8, we
show how to use JUnitPerf to ensure that unit tests execute within certain time limits and can handle
expected usage loads. JUnitPerf does not help you find performance problems. Instead, it ensures that
tests run within predefined performance limits.
You will often use JUnitPerf to complement commercial profiling tools. You may use a profiling tool
to isolate performance bottlenecks in your code. Once you have fixed the bottleneck, you write a
JUnitPerf test to ensure the code runs within acceptable time limits. The JUnitPerf test is then
automated, and will fail if someone changes code and makes the code slow again. At this point, you
probably go back to the profiling tool to locate the cause of the problem.
1.3.6 Application Servers
We round out our overview of tools with a brief mention of two open source server tools, JBoss and
Tomcat. JBoss is a free application server supporting EJB, while Tomcat is a servlet and JSP
container. The recipes in this book do not show how to use these tools in detail. Instead, we describe
how to configure JBoss and Tomcat in order to support automated testing and continuous integration.
The kind of automation we are interested in occurs when you compile code and run tests. As
mentioned earlier, you should strive for a simple command that compiles your code and then runs all
of your tests. When working with an application server, typing a command like ant junit may
actually do the following:
1. Compile all code.
2. Build a WAR file.
3. Start Tomcat if it is not already running.
4. Deploy the new WAR file.
5. Run all unit tests, including those written using HttpUnit.
6. Display a summary of the test results.
1.3.7 Setting Up a Build Server
At some point, your team will probably decide to create a build server. This is a shared machine that
performs a clean build of the software on a continuous basis. The build server ensures that your
application always compiles and that all tests run. The build server is easy to set up if you have been
using CVS and Ant all along. For the most part, the build server operates exactly like each developer's
PC. At various intervals throughout the day, the build server gets a clean copy of the code, builds the
application, and runs the test suite.
Over time, however, you may want to make the build server more sophisticated. For instance, you
might want the build server to monitor the CVS repository for changes. The build can start after some
files have changed, but should not do so immediately. Instead, it should wait for a brief period of
inactivity. The server can then get a clean copy of the sources using a timestamp from sometime
during the inactive period. This process ensures that the build server is not getting code while
programmers are committing changes to the repository.
You might also want to keep a change log of who changes what between each build, in order to notify
the correct developers whenever the build succeeds or fails. We have found that notifying the entire
team whenever a build fails is not a good idea because people begin to ignore the messages. With a
change log, you can notify only those people who actually made changes. The developer process then
begins to look like this:
• Make a change, following all of the steps outlined earlier.[7]
[7] In theory, the build shouldn't break if every developer follows the process before checking in
code. We have found, however, that people occasionally "break the build" no matter how careful
they are. An automated build server helps catch problems right away.
• Commit changes to CVS.
• Wait for an email from the build server indicating whether the build succeeds or fails.
There is a tool that does everything just described. It is called Cruise Control, and is available at
http://cruisecontrol.sourceforge.net. Cruise Control works in conjunction with Ant, CVS, and JUnit to
perform continuous builds on a server machine. The exact mechanics of setting up a build server vary
widely depending on what version-control tool you use, whether you are using Linux or Windows,
and what steps are required to build your particular application. The important thing to keep in mind is
that builds should become a seamless part of everyday activity on an XP project, ensuring that
developers can work without constantly stopping to figure out how to compile software and integrate
changes with other team members.
Chapter 2. XP Overview
This chapter provides a quick introduction to the key programming-related XP activities. These
activities are the aspects of XP that affect programmers the most.
XP encompasses much more than programming techniques. XP is a complete approach to software
development, including strategies for planning, gathering user requirements, and everything else
necessary to develop complete applications. Understanding these strategies is essential if you wish to
base an entire project on XP.
2.1 What Is XP?
XP is based on four key principles: simplicity, communication, feedback, and courage. This section
introduces each principle, and the remainder of this chapter touches on each concept where
appropriate.
2.1.1 Simplicity
Simplicity is the heart of XP. Applying the principle of simplicity affects everything you do, and
profoundly impacts your ability to successfully apply XP. Focusing on simple designs minimizes the
risk of spending a long time designing sophisticated frameworks that the customer may not want.
Keeping code simple makes changing code easier as the requirements inevitably change. In addition,
adopting simple techniques for communicating requirements and tracking progress maximizes
chances that the team will actually follow the process. Most importantly, focusing on simple solutions
to today's problems minimizes the cost of change over time. Figure 2-1 shows that the intended result
of XP practices is to tame the cost of change curve, making it increase much less over time than we
would otherwise expect.
Figure 2-1. Cost of change on an XP project
Traditional theory argues that software becomes increasingly expensive to change over the lifetime of
a project. The theory is that it is ten times harder to fix a mistake of requirements when you are in the
design phase, and 100 times harder to make changes late in a project during the coding phase. There
are many reasons. For one, there is more code to change as time goes on. If the design is not simple,
one change can affect many other parts of the system. Over time, as more and more programmers
change the system, it becomes increasingly complex and hard to understand.
The XP approach recognizes that the cost of change generally increases like one would expect, but
this increase is not inevitable. If you constantly refactor and keep your code simple, you can avoid
ever-increasing complexity. Writing a full suite of unit tests is another tool at your disposal, as
described later in this chapter. With complete regression testing, you have the ability to make big
changes late in the development cycle with confidence. Without these tests, the cost of change does
increase because you have to manually test everything else that you may have just broken.
There are other forces in XP projects that balance the rising cost of change. For example, collective
code ownership and pair programming ensure that the longer an XP project goes, the better and deeper
understanding the whole team has of the whole system.
2.1.2 Communication
Communication comes in many forms. For programmers, code communicates best when it is simple.
If it is too complex, you should strive to simplify it until the code is understandable. Although source
code comments are a good way to describe code, self-documenting code is a more reliable form of
documentation because comments often become out of sync with source code.
Unit tests are another form of communication. XP requires that unit tests be written for a vast majority
of the code in a system. Since the unit tests exercise the classes and methods in your application,
source code for the tests become a critical part of the system's documentation. Unit tests communicate
the design of a class effectively, because the tests show concrete examples of how to exercise the
class's functionality.
Programmers constantly communicate with one another because they program in pairs. Pair
programming means that two programmers sit at a single computer for all coding tasks; the two share
a keyboard, mouse, and CPU. One does the typing while the other thinks about design issues, offers
suggestions for additional tests, and validates ideas. The two roles swap often; there is no set observer
in a pair.
The customer and programmer also communicate constantly. XP requires an on-site customer to
convey the requirements to the team. The customer decides which features are most important, and is
always available to answer questions.
2.1.3 Feedback
Having an on-site customer is a great way to get immediate feedback about the project status. XP
encourages short release cycles, generally no longer than two weeks. Consider the problems when the
customer only sees new releases of your software every few months or so. With that much time in
between major feature releases, customers cannot offer real-time feedback to the programming team.
Months of work may be thrown away because customers changed their minds, or because the
programmers did not deliver what was expected.
With a short release cycle, the customer is able to evaluate each new feature as it is developed,
minimizing the necessity to rework and helping the programmers focus on what is most important to
the customer. The customer always defines which features are the most important, so the most
valuable features are delivered early in the project. Customers are assured that they can cancel the
project at any time and have a working system with the features that they value the most.
Code can offer feedback to programmers, and this is where good software development tools shine. In
XP, you use unit tests to get immediate feedback on the quality of your code. You run all of the unit
tests after each change to source code. A broken test provides immediate feedback that the most recent
change caused something in the system to break. After fixing the problem, you check your change into
version control and build the entire system, perhaps using a tool like Ant.
2.1.4 Courage
The concepts that were just described seem like common sense, so you might be wondering why it
takes so much courage to try out XP. For managers, the concept of pair programming can be hard to
accept—it seems like productivity will drop by 50%, because only half of the programmers are
writing code at any given time. It takes courage to trust that pair programming improves quality
without slowing down progress.[1]
[1] Check out http://www.pairprogramming.com for more information on the benefits of pair programming.
Focusing on simplicity is one of the hardest facets of XP for programmers to adopt. It takes courage to
implement the feature the customer is asking for today using a simple approach, because you probably
want to build in flexibility to account for tomorrow's features, as well. Avoid this temptation. You
cannot afford to work on sophisticated frameworks for weeks or months while the customer waits for
the next release of your application.[2] When this happens, the customer does not receive any feedback
that you are making progress. You do not receive feedback from the customer that you are even
working on the right feature!
[2] The best frameworks usually evolve instead of being designed from scratch. Let refactoring be the
mechanism for framework development.
Now, let's look at several specific concepts behind XP in more detail.
2.2 Coding
Coding is an art, and XP acknowledges that. Your success at XP depends largely on your love of
coding. Without good code, the exponential cost of change as shown in Figure 2-1 is inevitable. Let's
look at some specific ways that XP helps keep code simple.
One of the most frustrating misconceptions about XP is that it is a chaotic
approach to software development that caters to hackers. The opposite is true.
XP works best with meticulous, detail-oriented programmers who take great
pride in their code.
2.2.1 Simplicity
Just getting code to work is not good enough, because the first solution you come up with is hardly
ever the simplest possible solution. Your methods may be too long, which makes them harder to test.
You may have duplicated functionality, or you may have tightly coupled classes. Complex code is
hard to understand and hard to modify, because every little change may break something else in the
system. As a system grows, complexity can become overwhelming to the point where your only
remaining option is to start over.
When compared to beginners, expert programmers typically implement
superior solutions using fewer lines of code. This is a hint that simplicity is
harder than complexity, and takes time to master.
Simple code is self-documenting because you pick meaningful names, your methods are concise, and
your classes have clearly defined responsibilities. Simple code is hard to achieve, and relies on
knowledge in the areas of object-oriented programming, design patterns, and other facets of software
engineering.
2.2.2 Comments
If code is self-documenting, do you need source code comments? In short, there will always be cases
where you need comments, but you should never write comments simply for the sake of commenting.
If the meaning of a method is completely obvious, you do not need a comment. An abundance of
comments in code is often an indication that the code is unclear and in need of refactoring. Let's look
at a method that needs a comment, and see how to eliminate this need.
/**
* Sets the value of x.
* @param x the horizontal position in pixels.
*/
public void setX(int x) {
this.x = x;
}
This method needs a comment because the meaning of "x" is not entirely clear. Over time, the
comment might not be kept in sync if someone changes the method's implementation or signature. But
what if we rename things to make the code more clear? How about this:
public void setXPixelPosition(int xPixelPosition) {
this.xPixelPosition = xPixelPosition;
}
This code no longer needs a comment because it is self-documenting. As a result, we end up typing a
little bit more for the method declaration, but save a few lines of comments. This helps us out in the
long run because we don't have to spend time and effort keeping the comment in sync with the code.
Long method names do not degrade performance in any appreciable way, and are easy to use thanks to
code-completion features found in any modern IDE.
2.2.3 Pair Programming
As mentioned earlier, XP teams work in pairs. These pairs of programmers share a single computer,
keyboard, and mouse. Having dual monitors is a good idea because both programmers can then see
the screen clearly, although this is not a requirement. Desks should be configured so that two people
can sit side-by-side comfortably, and the entire team should work in the same room.
Here is how pair programming works:
1. You pick out a user story[3] for your next task.
[3] A user story is a requirement from the customer. Stories are typically written on index cards, and
the customer decides which stories are the most important.
2. You ask for help from another programmer.
3. The two of you work together on a small piece of functionality.
o Try to work on small tasks that take a few hours.
o After the immediate task is complete, pick a different partner or offer to help
someone else.
By working on small tasks, partners rotate frequently. This method facilitates communication between
team members and spreads knowledge. As mentioned earlier, writing simple code is hard, and
experienced programmers are generally better at it. By pairing people together, beginners can gain
valuable coding experience from the experts.
Pair programming is critical because XP requires a very high degree of discipline in order to be
successful. As we will learn in the next section, programmers must write unit tests for each new
feature added to the application. Writing tests takes a great deal of patience and self-discipline, so
having a partner often keeps you honest. When you start to get lazy about writing tests, it is the
partner's job to grab the keyboard and take over.
When you have control of the keyboard, you are thinking about the code at a very fine-grained level of
detail. When you are not the partner doing the typing, you have time to think about the problem at a
higher level of abstraction. The observer should look for ways to simplify the code, and think about
additional unit tests. Your job is to help your partner think through problems and ultimately write
better code.
2.2.4 Collective Code Ownership
XP teams do not practice individual code ownership. Every team member is able to work on any piece
of code in the application, depending upon the current task. The ability to work on any piece of code
in an application makes sense when pairs of programmers are constantly shuffling and re-pairing
throughout the day. Over time, most of the programmers see and work on code throughout the
application.
Collective code ownership works because you can always ask someone else for help when you work
on unfamiliar classes. It also works because you have a safety net of unit tests. If you make a change
that breaks something, a unit test should catch the error before you and your partner integrate the
change into the build. The tests also serve as great documentation when you are working with
unfamiliar code.
Collective ownership facilitates communication among team members, avoiding situations where the
entire team depends on the one person who understands the custom table sorting and filtering
framework. The shared ownership model also encourages higher quality, because programmers know
that other team members will soon be looking at their code and potentially making changes.
2.2.5 Coding Standards
Collective code ownership and pair programming ensure that all team members are constantly looking
at each other's code. This is problematic when some programmers follow radically different coding
conventions. Your team should agree on a consistent set of coding conventions in order to minimize
the learning curve when looking at each other's code.
Picking coding conventions can turn into a bitter argument, as programmers become very attached to
their personal style. It's ironic, because code style has absolutely no bearing on the functionality of the
compiled application.
Consider using a code-formatting tool that automatically formats code
according to your team standards.
If everyone on your team is agreeable, coding standards might be a non-issue. Otherwise, either try to
hammer out an agreement or select an industry standard set of conventions such as the JavaSoft
coding guidelines.[4] You might be able to win people over by adopting standards written by a neutral
party.
[4] The examples in this book follow JavaSoft coding guidelines, available at
http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html/.
2.2.6 Code Inspections
Code inspections are a great technique for validating the quality of code. In typical projects,
programmers work in isolation for several weeks, and then present their code to a group of peers for a
formal inspection meeting. People often talk about how great code inspections are, but procrastinate
until the last minute. At this point, it is generally too late to inspect everything and it might be too late
to make changes if you find problems.
Code inspections are a valuable tool, so why not inspect code constantly? XP teams do not rely on
formal code inspections, primarily because all of the code is constantly reviewed as it is developed by
pairs of programmers. As programmers migrate to new partners and work on different parts of the
system, code is constantly enhanced and refactored by people other than the original author.
2.3 Unit Testing
A unit test is a programmer-written test for a single piece of functionality in an application. Unit tests
should be fine grained, testing small numbers of closely-related methods and classes. Unit tests should
not test high-level application functionality. Testing application functionality is called acceptance
testing, and acceptance tests should be designed by people who understand the business problem
better than the programmers.
2.3.1 Why Test?
XP cannot be done without unit testing. Unit tests build confidence that the code works correctly.
Tests also provide the safety net enabling pairs of programmers to make changes to any piece of code
in the system without fear. Making changes to code written by someone else takes courage, because
you might not be familiar with all of the ins-and-outs of the original solution.
Imagine a scenario in which you are presented with a legacy payroll application consisting of 50,000
lines of code and zero unit tests. You have been asked to change the way that part-time employee
salaries are computed, due to a recent change in the tax laws. After making the change, how can you
be confident that you did not introduce a bug somewhere else in the system? In a traditional model,
you hand the application to a quality assurance team that manually tests everything they can think of.[5]
Hopefully, everybody gets the correct paycheck next month.
[5] Most companies would like to have dedicated QA teams, but few of these teams seem to exist. XP
requires that programmers take on more responsibility for testing their own code.
Now imagine the XP scenario. If the original development team used XP, each class would have a
suite of automated unit tests. Before you make your change, you run all of the unit tests to ensure they
pass. You then write a new unit test for your new payroll calculation feature. This new test fails,
because you have not written the new feature yet. You then implement the new feature and run all of
the tests again.
Once all of the tests pass, you check in your code and feel confident that you did not break something
else while making the improvement.[6] This is called test-driven development, and it is how XP teams
operate.
[6] This confidence is justified because of the extensive test suite.
2.3.2 Who Writes Unit Tests?
Programmers write unit tests. Unit tests are designed to test individual methods and classes, and are
too technical for nonprogrammers to write. It is assumed that programmers know their code better
than anyone else, and should be able to anticipate more of the problems that might occur.
Not all programmers are good at anticipating problems. This is another example of the benefit of pair
programming. While one partner writes code, the other is thinking of devious ways to break the code.
These ideas turn into additional unit tests.
2.3.3 What Tests Are Written?
Unit tests should be written for any code that is hard to understand, and for any method that has a
nontrivial implementation. You should write tests for anything that might break, which could mean
just about everything.
So what don't you test? This comes down to a judgment call. Having pairs of people working together
increases the likelihood that tests are actually written, and gives one team member time to think about
more tests while the other writes the code. Some would argue that tests do not have to be written for
absolutely trivial code, but keep in mind that today's trivial code has a tendency to change over time,
and you will be thankful that you have tests in place when those changes occur.
There will always be scenarios where you simply cannot write tests. GUI code is notoriously difficult
to test, although Chapter 4 offers recipes for testing Swing GUIs using JUnit. In these cases, your
programming partner should push you to think hard and make sure you really cannot think of a way to
write a test.
2.3.4 Testing New Features
XP teams write tests before each new feature is added to the system. Here is the test-driven process:
1. Run the suite of unit tests for the entire project, ensuring that they all pass.
2. Write a unit test for the new feature.
3. You probably have to stub out the implementation in order to get your test to compile.
4. Run the test and observe its failure.
5. Implement the new feature.
6. Run the test again and observe its success.
At this point, you have tested one facet of your new feature. You and your programming partner
should now think of another test, and follow this process:
1. Write another test for some aspect of the new function that might break, such as an illegal
method argument.
2. Run all of your tests.
3. Fix the code if necessary, and repeat until you cannot think of any more tests.
Once your new feature is fully tested, it is time to run the entire suite of unit tests for the entire project.
Regression testing ensures that your new code did not inadvertently break someone else's code. If
some other test fails, you immediately know that you just broke it. You must fix all of the tests before
you can commit your changes to the repository.
2.3.5 Testing Bugs
You also write unit tests when bugs are reported. The process is simple:
1. Write a test that exposes the bug.
2. Run the test suite and observe the test failure.
3. Fix the bug.
4. Run the test suite again, observing the test succeeding.
This is simple and highly effective. Bugs commonly occur in the most complicated parts of your
system, so these tests are often the most valuable tests you come up with. It is very likely that the
same bug will occur later, but the next time will be covered because of the test you just wrote.
2.3.6 How Do You Write Tests?
All tests must be pass/fail style tests. This means that you should never rely on a guru to interpret the
test results. Consider this test output:
Now Testing Person.java:
First Name: Tanner
Last Name: Burke
Age: 1
Did this test pass or fail? You cannot know unless you are a "guru" who knows the system inside and
out, and know what to look for. Or you have to dig through source code to find out what those lines of
text are supposed to be. Here is a much-improved form of test output:
Now Testing Person.java:
Failure: Expected Age 2, but was 1 instead.
Once all of your tests are pass/fail, you can group them together into test suites. Here is some
imaginary output from a test suite:
Now Testing Person.java:
Failure: Expected Age 2, but was 1 instead
Now Testing Account.java:
Passed!
Now Testing Deposit.java:
Passed!
Summary: 2 tests passed, 1 failed.
This is a lot better! Now we can set up our Ant buildfile to run the entire test suite as part of our
hourly build, so we have immediate feedback if any test fails. We can even instruct Ant to mail the
test results to the entire team should any test fail.
Writing effective tests takes practice, just like any other skill. Here are a few tips for writing effective
tests:
• Test for boundary conditions. For instance, check the minimum and maximum indices for
arrays and lists. Also check indices that are just out of range.
• Test for illegal inputs to methods.
• Test for null strings and empty strings. Also test strings containing unexpected whitespace.
2.3.7 Unit Tests Always Pass
The entire suite of unit tests must always pass at 100% before any code is checked in to the source
repository. This ensures that each programming pair can develop new features with confidence. Why?
Because when you change some code and a test starts to fail, you know that it was your change that
caused the failure. On the other hand, if only 98% of the unit tests passed before you started making
changes, how can you be confident that your changes are not causing some of the tests to fail?
2.3.8 Testing Improves Design
Writing good unit tests forces you to think more about your design. For GUIs, you must keep business
logic clearly separated from GUI code if you have any hope of testing it. In this respect, the tests force
you to write independent, modular code.
Writing tests also leads you to write simpler methods. Methods that perform four calculations are hard
to test. But testing four methods, each of which performs a single calculation, is straightforward. Not
only is the testing easier when your methods are concise—the methods become easier to read because
they are short.
2.3.9 Acceptance Testing
When you need to test high-level application functionality, turn to acceptance testing. This sort of
testing is driven by the customer, although they will probably need help from a programmer to
implement the tests.
Unit or Acceptance Tests?
If you find that your unit tests require lots of complex initialization logic, or they have
numerous dependencies that are making it hard for you to change code without rewriting
your tests, you may have actually written acceptance tests, rather than unit tests.
Unit tests should test very fine-grained functionality, such as individual classes and
methods. As your unit tests grow more and more complex, they start to take on the flavor of
acceptance tests instead of unit tests. While these kinds of tests are valuable, it is hard to
ensure that they run at 100% success because they have so many dependencies.
Like unit tests, acceptance tests should be designed to pass or fail, and they should be as automated as
possible. Unlike unit tests, however, acceptance tests do not have to pass at 100%. Since programmers
do not run the suite of acceptance tests with each and every change, it is likely that acceptance tests
will occasionally fail. It is also likely that the acceptance tests will be created before all of the
functionality is written.
The customer uses acceptance tests for quality assurance and release planning. When the customer
deems that the critical acceptance tests are passing to their satisfaction, which is probably 100%, the
application can be considered finished.
2.4 Refactoring
Refactoring[7] is the practice of improving the design of code without breaking its functionality. In
order to keep code simple and prevent the cost of making changes from skyrocketing, you must
constantly refactor. This keeps your code as simple as possible.
[7] See Refactoring: Improving the Design of Existing Code by Martin Fowler, et al. (Addison-Wesley).
Here is a simple refactoring. Suppose you have this code:
public class Person {
private String firstName;
public void setFirst(String n) {
this.firstName = n;
}
}
This code can be improved by picking a better argument name, changing n to firstName:
public class Person {
private String firstName;
public void setFirst(String firstName) {
this.firstName = firstName;
}
}
The code can be improved even further by renaming the method to setFirstName( ):
public class Person {
private String firstName;
public void setFirstName(String firstName) {
this.firstName = firstName;
}
}
The method has been refactored and is now more easily understandable. Of course, changing the
method name requires you to change all references to the method throughout your application. This is
where a good IDE can help out, because it can identify all usages and update the calls automatically.
2.4.1 Goals
You refactor code to make it simpler. Each individual refactoring introduces a small improvement;
however, these small improvements add up over time. By constantly striving to keep code as concise
and as simple as possible the cost of making changes to an application does not rise so dramatically
over time.
Removing duplication is another goal of refactoring that deserves mention. Duplicated logic is almost
always harder to maintain because changes must be made to more than one part of the system as it
evolves. We have found that duplicated logic is often a signal that code should be refactored and
simplified.
Without refactoring, complexity inevitably increases as more and more features are tacked onto a
system. Increasing complexity is known as entropy, and is a fundamental reason why the cost of
change increases over time. Our goal is to stave off entropy as long as possible through constant
refactoring.
2.4.2 When to Refactor
You should refactor constantly, throughout the lifetime of a project. Your customer and manager will
not ask you to refactor your code, just like they probably won't ask you to write unit tests. Instead, this
is a practice that must be engrained into your daily routine. Each time you fix a bug or add a new
feature, look for overly complex code. Look for chunks of logic that are duplicated and refactor them
into a shared method. Try to rename methods and arguments so they make sense, and try to migrate
poorly designed code towards better usage of design patterns.
Writing unit tests is a great way to identify portions of code that need refactoring. When you write
tests for a class, your test is a client of that class. You will have first-hand experience using the class,
and will be the first to realize when the API is overly complicated. Use this opportunity to refactor the
API and make it simple to use.
2.4.3 How to Refactor
Refactoring works hand-in-hand with automated unit testing. Before you refactor code, make sure you
have a working unit test on hand. Assuming that the test works before the refactoring effort, it should
also work after you are done refactoring. This process is similar to any new feature or bug fix that you
put into the system:
1. Make sure you have a working unit test for the feature you are about to refactor.
2. Do the refactoring, or a portion of the refactoring.
3. Run the test again to ensure you did not break anything.
4. Repeat steps 2-4 until you are finished with the refactoring.
2.4.4 Refactoring Tools
Most new IDEs on the market offer rudimentary support for refactoring, and this is constantly
improving. Some key features to look for include:
• The ability to rapidly find usages for fields, methods, and classes. This ability makes it easier
for you to determine what will break if you start changing things.
• The ability to automatically rename fields, methods, classes, and other entities. All references
to those items should be updated automatically.
• The ability to automatically convert a selected block of code into a method call. This is called
Extract Method in most refactoring tools.
These are just the tip of the iceberg. Many tools already do much more than this.
2.5 Design
XP does not encourage a lot of up-front design. Instead, the XP approach recognizes that humans
cannot accurately design every single feature of an application before writing code. So why not design
a little bit right away and then write the code immediately? As a result, your customer can get his or
her hands on some working software right away.
XP practitioners typically obsess about good design, taking it much more seriously than other
developers. They simply have a different point of view on when to do it—all the time, instead of all at
the beginning.
2.5.1 Design Today's Features
Customers define which features are most important, and programmers work on those features first.
As each new feature is implemented, the application is delivered to customers and they have the
opportunity to offer immediate feedback.
In this customer-centric delivery model, we do not have time to spend months and months of time
doing detailed design and analysis. We also cannot afford to develop complex frameworks to
accommodate every anticipated feature. If we did either of these things, we would not be able to
deliver working code (and thus get feedback) to the customer in a timely fashion.
Figure 2-2 shows the relationship between time-to-customer and the likelihood that the finished
product does not meet expectations. Stated simply, the longer you work in a vacuum without getting
feedback from your customer, the higher the probability is that you will develop the wrong features.
Figure 2-2. Strive for short release cycles
This is where courage comes back into the picture. The best developers may have the most trouble
accepting the fact that they should not worry so much about framework development. Instead, they
should worry more about writing exactly what the customer wants today, along with extensive unit
tests. The code may or may not be reusable, but we can resolve that later using refactoring techniques.
2.5.2 Simple Design
People on XP teams use a lot of index cards and whiteboards. Since you are only working on one
small feature at a time, you rarely have to develop complex design models. Instead, you come up with
a good design for the feature you are working on, and then you write your unit tests and code.
When you move on to the next feature, you do additional design work if necessary. The original
design documents are generally not useful, because code can change and people rarely bother to keep
design documents in sync with code, anyway. The code itself is the most reliable design document in
existence. The next best thing is the unit tests, because they show how to use your code.
2.5.3 UML
Unified Modeling Language (UML) can be used on XP projects, but only to the extent that it helps
you deliver requested features to customers. A UML class diagram can make it far easier to visualize
the static relationship between classes, and a sequence diagram can make dynamic behavior much
easier to see. The point is to make programming tasks easier, and nothing more. If you need to use
UML to design the feature you are working on right now, then by all means work on that UML. But
far too many project teams spend inordinate amounts of time perfecting diagram after diagram, only to
find that the customer changed his mind after seeing the finished product.
2.5.3.1 UML tools
If you really want up-to-date UML diagrams, consider tools like JBuilder Enterprise Studio, Together
Control Center, or Rational XDE. These types of tools can reverse-engineer your code and produce
UML diagrams. These tools ensure that the diagrams stay in sync with your code. XP encourages you
to throw away UML diagrams once you have written your code. With these tools, you can generate
correct, current UML any time it is needed.
2.5.3.2 Whiteboards and scratch paper
You don't need fancy, expensive UML diagramming tools. A stack of index cards, a whiteboard, or
even a scrap of paper can serve as a surprisingly effective design tool. Here is the process:
1. Draw a diagram.
2. Write a unit test.
3. Write some code.
4. Repeat steps 2-3 until the feature is complete.
5. Throw away the diagram.
This may seem silly, but think back to the last project you worked on where a lot of diagrams were
created. When you encountered a bug in the application, did you generally turn to diagrams first, or
look at the code? XP assumes that most programmers rely on the code, because diagrams do not
present enough detail and manually updated diagrams are almost always out of date with respect to the
actual code.
Throwing away diagrams does not imply that you throw away the "design." The design itself is
embodied in the working code, and can only be thrown away if the code is erased.
2.6 Builds
A good build environment is essential to XP teams. Constant refactoring, collective code ownership,
and ever-changing pair programming teams require that each developer have the ability to reliably
build the software using an identical configuration. If this is not the case, then tests that pass for one
developer may fail for everyone else.
2.6.1 Continuous Integration
Continuous integration means that XP teams build the software application frequently, often several
times per day. In fact, the Cruise Control tool (mentioned in Chapter 1) performs a complete build of
the application after every check-in to version control.
After you and your programming partner have finished a task, you should integrate your changes with
the shared source code repository. This means that you check in your changes to your version control
tool, run a complete build, and run all of the unit tests. If any tests fail, you fix them right away.
Since you probably build your application many times per day, you won't have any trouble when it
comes time to deliver a build to your customer. For this task, you might want to define a script that
copies the latest build to a "stable" build directory of some sort. This gives the customers a stable
playground from which to run and test the application while the programmers continue with their dayto-
day coding and builds.
There is no reason why automated builds should not go all the way to a customer deliverable. For
example, if you are building a shrink-wrap product, going all the way to an installation CD image is
not a bad idea. The desire to create completely automated build processes is very much in tune with
the desire to create automated test suites. Taking manual, human-controlled steps out of the process
improves quality and lets you focus on delivering features to customers rather than working on
mundane software compilation steps.
2.6.2 Small Tasks
Continuous integration works best when pairs of programmers work on small tasks. Once each task is
tested and implemented, it should be integrated with the main build as soon as possible. This is the
best way to ensure that all of the team members are in sync with one another.
When programmers get sidetracked on large, complex tasks, they fall out of sync with the rest of the
team. You should avoid situations where you have dozens of files checked out for days and weeks at a
time. If this happens often, it may be an indication that you are not integrating often enough. Or, it
may suggest that changes to one class are forcing changes in many other classes throughout the
system. It could be time for some refactoring to break the dependencies.
Chapter 3. Ant
Section 3.1. Introduction
Section 3.2. Writing a Basic Buildfile
Section 3.3. Running Ant
Section 3.4. Providing Help
Section 3.5. Using Environment Variables
Section 3.6. Passing Arguments to a Buildfile
Section 3.7. Checking for the Existence of Properties
Section 3.8. Defining a Classpath
Section 3.9. Defining Platform-Independent Paths
Section 3.10. Including and Excluding Files
Section 3.11. Implementing Conditional Logic
Section 3.12. Defining a Consistent Environment
Section 3.13. Preventing Build Breaks
Section 3.14. Building JAR Files
Section 3.15. Installing JUnit
Section 3.16. Running Unit Tests
Section 3.17. Running Specific Tests
Section 3.18. Generating a Test Report
Section 3.19. Checking Out Code from CVS
Section 3.20. Bootstrapping a Build
3.1 Introduction
Ant is a portable, Java-based build tool designed to support software builds—and many other tasks—
on any platform supporting Java. An XML file known as a buildfile specifies which tasks Ant follows
when building your project. Ant ships with well over 100 tasks that perform operations ranging from
compiling code to playing sound files when a build finishes. Java classes implement Ant tasks that can
do anything Java can do. The Ant API is open and designed for extensibility; you can write your own
custom tasks if the need arises.
A good build tool like Ant is critical to any successful XP implementation. You cannot expect a team
of programmers to constantly refactor their code, run unit tests, and integrate their changes without a
fast, predictable build environment. Consider the problems that occur when one of the programmers
on a team has a newer version of a JAR file on his classpath. Unit tests may pass on his machine, but
fail for everyone else. Ant helps avoid this sort of problem by clearly defining the files the project
depends on, and the steps are followed to perform the build.
Build times must be kept to a minimum and Ant excels in this area. XP assumes that programmers
write a lot of small, incremental pieces of code. Programmers must compile and run all unit tests after
making each small change; therefore, the build needs to be fast. When builds are slow, programmers
are discouraged from the constant refactoring and testing that XP demands. Ant helps performance in
several ways:
• Most tasks only do their work if files are out of date. For example, code is only compiled
when .java files are newer than their corresponding .class files.
• In most cases, individual build steps execute in the same JVM. Ant is written in Java and
efficiently invokes many tools, such as the Java compiler, through direct method calls rather
than spawning new processes.
• Ant tasks use a simple pattern-matching syntax to locate files quickly, allowing you to write
buildfiles that perform work on the correct subset of a source tree for the job at hand.
Ant is available from the Apache Software Foundation at http://jakarta.apache.org/ant. Because Ant
has so many tasks, the recipes in this chapter cannot describe them all. Instead, we show the most
common aspects of Ant buildfiles followed by specific discussion of the tasks most directly related to
XP.
3.2 Writing a Basic Buildfile
3.2.1 Problem
You want to write a basic Ant buildfile.
3.2.2 Solution
Example 3-1 lists a simple Ant buildfile that you may use as a boilerplate for your own projects.
Example 3-1. Boilerplate Ant buildfile
<?xml version="1.0"?>
<project name="Template Buildfile" default="compile"
basedir=".">
<property name="dir.src" value="src"/>
<property name="dir.build" value="build"/>
<property name="dir.dist" value="dist"/>
<!-- Creates the output directories -->
<target name="prepare">
<mkdir dir="${dir.build}"/>
<mkdir dir="${dir.dist}"/>
</target>
<target name="clean"
description="Remove all generated files.">
<delete dir="${dir.build}"/>
<delete dir="${dir.dist}"/>
</target>
<target name="compile" depends="prepare"
description="Compile all source code.">
<javac srcdir="${dir.src}" destdir="${dir.build}"/>
</target>
<target name="jar" depends="compile"
description="Generates oreilly.jar in the 'dist'
directory.">
<jar jarfile="${dir.dist}/oreilly.jar"
basedir="${dir.build}"/>
</target>
</project>
3.2.3 Discussion
You generally call this file build.xml, and can put it anywhere you like. In our example, the buildfile is
found in the directory containing the src directory. The <project> tag is found in all buildfiles:
<project name="Template Buildfile" default="compile"
basedir=".">
The project name should be something descriptive, as this may show up when you run Ant from other
tools. The default attribute specifies which target is invoked when the user types ant. Finally,
the basedir attribute specifies the directory from which all paths are relative to. Regardless of
where you invoke Ant, "." is the directory containing the buildfile.
Although you can put build.xml anywhere, we encounter the fewest difficulties
when it is placed at the root of the project tree.
To invoke other targets, you type something like ant jar or ant clean compile. If the
buildfile were called myproj.xml, you would type ant -buildfile myproj.xml clean.
The remainder of our buildfile consists of tasks and targets. The end user invokes targets by name;
tasks perform the actual work. The property task, for example, defines name/value pairs to avoid
hardcoding throughout the buildfile:
<property name="dir.src" value="src"/>
The prepare target is a convention used in nearly every buildfile:
<target name="prepare">
<mkdir dir="${dir.build}"/>
<mkdir dir="${dir.dist}"/>
</target>
This creates the output directories relative to the project's base directory. If the directories already
exist, the mkdir task ignores the request. Our example shows how the prepare target comes into
action via target dependencies:
<target name="compile" depends="prepare"
description="Compile all source code.">
<javac srcdir="${dir.src}" destdir="${dir.build}"/>
</target>
Since the compile target depends on prepare, the output directories are always created before
the compiler runs. Like other Ant tasks, the javac task only performs work if it has to. In this case,
it only compiles .java files that are newer than their corresponding .class files.
It is important to note that checking timestamps on files results in fast builds,
but does not catch logical dependencies between files. For instance, changing
methods in a base class will not trigger a recompile on derived classes. For this
reason, it is a good idea to type ant clean compile frequently. If you
are using a version control tool like CVS, perform a clean compile just before
checking in code so you don't "break the build" for other developers.
3.2.4 See Also
Ant ships with an optional task called depend that calculates dependencies based on references
found inside of .class files, rather than merely checking file timestamps. You might also want to
consider using IBM's Jikes compiler, since it is generally considered to be faster than Sun's javac
compiler and it can provide better errors and warnings. See the Ant documentation for the javac
task to learn how to use Jikes with Ant.
3.3 Running Ant
3.3.1 Problem
You want to run Ant.
3.3.2 Solution
The complete command-line syntax is as follows:
ant [options] [target [target2 [target3] ...]]
3.3.3 Discussion
Table 3-1 lists all of the Ant command-line options. This table applies to Ant Version 1.5.1.
Table 3-1. Ant command-line options
Option Description
-buildfile file
-f file
-file file
Specify which buildfile to use. If omitted, Ant searches for a file
named build.xml.
-Dproperty=value Pass name/value pairs as properties.
-debug Write debugging information as the build progresses.
-diagnostics Write diagnostic information as the build progresses.
-emacs Write the log file in a way that Emacs understands.
-find file
Locate a buildfile. Start searching in this directory, then the parent
directory, and so on until the file is found or the filesystem root is
reached.
-help Show these options.
-inputhandler
classname Use a custom input handler class.
-listener
classname Use a custom build listener class.
-logfile file
Send messages to the specified file instead of the console.
Table 3-1. Ant command-line options
Option Description
-l file
-logger classname Use a custom logger class.
-projecthelp Show a list of all targets in the buildfile.
-propertyfile name Load all of the properties in the specified file. Properties specified with
-D take precedence.
-quiet
-q
Suppress much of the output.
-verbose
-v
Write more information as the build progresses.
-version Show the version of Ant.
3.3.4 See Also
Type ant -help to see the Ant options.
3.4 Providing Help
3.4.1 Problem
You want to provide help messages in your buildfiles.
3.4.2 Solution
Include a description attribute on the <project> and <target> tags. Also consider
writing a help target, and use XML comments throughout the buildfile.
3.4.3 Discussion
Example 3-2 shows several techniques for providing additional help in Ant buildfiles. In this example,
the help target is listed as the default target and is executed when the user types ant at the
command line.
Example 3-2. Various ways to provide help
<?xml version="1.0"?>
<!-- You can document the buildfile using XML comments -->
<project name="My Big Project" default="help" basedir=".">
<description>Shows how to provide help in an Ant
buildfile.</description>
<property name="dir.src" value="src"/>
<target name="help">
<echo message="This buildfile shows how to get help."/>
<echo>(Type 'ant -projecthelp' for more info)</echo>
<echo><![CDATA[
Here is a block of text
that you want to format
in a very specific way!]]></echo>
</target>
<!-- Here is an example of a subtarget -->
<target name="prepare">
<mkdir dir="${dir.build}"/>
<mkdir dir="${dir.dist}"/>
</target>
<!-- Here is an example of a main target -->
<target name="clean"
description="Remove all generated files.">
<delete dir="${dir.build}"/>
<delete dir="${dir.dist}"/>
</target>
<target name="compile" depends="prepare"
description="Compile all source code.">
<javac srcdir="${dir.src}" destdir="${dir.build}"/>
</target>
</project>
The help target uses the echo task to print some usage information for Ant beginners. It reminds
the user of the -projecthelp option, and uses an XML CDATA section to format a paragraph of
text. CDATA sections are useful whenever you want to preserve linefeeds, spaces, and other
characters precisely. CDATA is also useful because it allows you to print special XML characters like
"<" without using entities like "&lt;".
Providing target descriptions is very useful:
<target name="clean"
description="Remove all generated files.">
These descriptions are displayed when the user types ant -projecthelp. Targets with
descriptions are displayed as main targets, while those without descriptions are called subtargets, and
are only displayed if you also include the -verbose command-line flag. Because of the distinction
between main targets and subtargets, you should only define description attributes for targets
you want the user to actually use.
3.4.4 See Also
Recipe 3.7 shows how to use the fail task to abort the build if a property is not set.
3.5 Using Environment Variables
3.5.1 Problem
You want to obtain and use environment variables within Ant. This is a way to avoid hardcoding
values in buildfiles.
3.5.2 Solution
Use a special form of the <property> task:[1]
[1] This technique only works with Ant 1.3 and later.
<?xml version="1.0"?>
<project name="envSample" default="deploy" basedir=".">
<!-- Set up the 'env' prefix for environment variables -->
<property environment="env"/>
<!-- Abort the build if TOMCAT_HOME is not set -->
<target name="checkTomcatHome" unless="env.TOMCAT_HOME">
<fail message="TOMCAT_HOME must be set!"/>
</target>
<target name="compile">
... compile the code
</target>
<!-- Deploy the WAR file to TOMCAT_HOME/webapps -->
<target name="deploy" depends="checkTomcatHome,compile">
<echo>Deploying to ${env.TOMCAT_HOME}</echo>
<copy file="myapp.war"
todir="${env.TOMCAT_HOME}/webapps"/>
</target>
</project>
3.5.3 Discussion
Although most operating systems support the concept of environment variables, not all do. As a result,
Sun deprecated Java's System.getEnv( ) method, which used to return the values of
environment variables. Undeterred by this restriction, Ant's programmers added the ability to obtain
environment variables using the technique shown here.
Use the property task's environment attribute to define a prefix, conventionally "env". Then
use this prefix when referencing environment variables in other parts of a buildfile, as if you are
referencing any normal Ant property. Our example Ant buildfile uses the TOMCAT_HOME
environment variable to deploy a Web Application Archive (WAR) file to the correct directory.
Our example takes this technique to the next level by verifying that TOMCAT_HOME is actually set
before attempting to deploy the WAR file. This is done in the checkTomcatHome target:
<target name="checkTomcatHome" unless="env.TOMCAT_HOME">
<fail message="TOMCAT_HOME must be set!"/>
</target>
Any other target requiring TOMCAT_HOME should list checkTomcatHome as a dependency:
<target name="deploy" depends="checkTomcatHome,compile">
Environment variables should be used sparingly, but are particularly valuable when deploying to
servers like Tomcat that might be installed in different locations depending on who is running the
buildfile.
Portability is the main limitation with this technique. Since the underlying Java libraries no longer
support System.getEnv( ), Ant must rely on Runtime.exec( ) to execute platformspecific
commands when obtaining environment variables. While this is supported for Unix,
Windows, and several other operating systems, you should definitely test things out if your buildfiles
must run on some other platform.
Properties Files
An alternative to both environment variables, and the system properties approach described
in Recipe 3.6 is a properties file that each developer uses to tell the build process about their
environment. You might want to name the file local.properties. Advantages include:
• All developer-specific settings are in one place—it's a file you don't check in to
source control.
• It's cross-platform.
• It's easy to edit, and the settings "stay put."
• It's easy for two or more developers to diff their settings.
You load it with <property file="local.properties">.
3.5.4 See Also
See the Ant user manual for the property core task.
3.6 Passing Arguments to a Buildfile
3.6.1 Problem
You want to pass system properties to a buildfile. Java system properties are a more portable
alternative to environment variables.
3.6.2 Solution
Pass the system properties to Ant using the -D command-line argument. For example:
ant -Dprop1="My Property" run
Within the buildfile, refer to the property using Ant's ${prop1} syntax. You can specify default
values for properties using the <property> tag, and you can pass system properties to Java
applications using the <sysproperty> tag nested within the <java> element.
3.6.3 Discussion
Example 3-3 shows an Ant buildfile that demonstrates system properties. It echoes the property
name/value pairs to the console, and then invokes a Java application that echoes the same properties.
Example 3-3. Buildfile demonstrating system properties
<?xml version="1.0"?>
<project name="sysprops" default="run" basedir=".">
<!-- define two properties -->
<property name="prop1" value="Property 1 from Buildfile"/>
<property name="prop2" value="Property 2 from Buildfile"/>
<target name="clean">
<delete dir="com"/>
</target>
<target name="compile">
<javac srcdir="." destdir=".">
<classpath path="."/>
</javac>
</target>
<target name="run" depends="compile">
<!-- echo each of the properties to the console -->
<echo message="Now in buildfile..."/>
<echo message="prop1 = ${prop1}"/>
<echo message="prop2 = ${prop2}"/>
<!-- The 'prop3' property must be defined on the command
line or it shows up like '${prop3}' -->
<echo message="prop3 = ${prop3}"/>
<echo message="user.home = ${user.home}"/>
<!-- execute the main( ) method in a Java class -->
<java classname="com.oreilly.javaxp.ShowProps">
<classpath path="."/>
<!-- pass one of the properties -->
<sysproperty key="prop1" value="${prop1}"/>
</java>
</target>
</project>
Our buildfile defines two properties. Regardless of where properties are defined, they are globally
visible:
<property name="prop1" value="Property 1 from Buildfile"/>
<property name="prop2" value="Property 2 from Buildfile"/>
Properties are always name/value pairs, and can be overridden from the command line (shown
shortly). They are referenced later in the buildfile using the ${prop1} and ${prop2} syntax.
The run target echoes these property name/value pairs, and you can override them from the
command-line:
<echo message="prop1 = ${prop1}"/>
<echo message="prop2 = ${prop2}"/>
<!-- The 'prop3' property must be defined on the command
line or it shows up like '${prop3}' -->
<echo message="prop3 = ${prop3}"/>
<echo message="user.home = ${user.home}"/>
As you can see, the buildfile tries to echo prop3 and user.home, even though they were not
defined earlier. As the comment indicates, the value for prop3 must be specified on the commandline
or it will be undefined. The user.home property is a standard Java system property, so it will
have a default value.
Finally, the buildfile invokes a Java application, but passes only one of the properties:
<!-- pass one of the properties -->
<sysproperty key="prop1" value="${prop1}"/>
Now let's look at a little Java program that displays the same properties. Example 3-4 shows how you
use System.getProperty( ) to retrieve system properties.
Example 3-4. Java application to print properties
package com.oreilly.javaxp;
public class ShowProps {
public static void main(String[] args) {
System.out.println("Now in ShowProps class...");
System.out.println("prop1 = " +
System.getProperty("prop1"));
System.out.println("prop2 = " +
System.getProperty("prop2"));
System.out.println("prop3 = " +
System.getProperty("prop3"));
System.out.println("user.home = " +
System.getProperty("user.home"));
}
}
To tie this all together, let's look at some sample output. When the user types ant, they see the output
shown next. This is the result of the default target, run, being executed.
[echo] Now in buildfile...
[echo] prop1 = Property 1 from Buildfile
[echo] prop2 = Property 2 from Buildfile
[echo] prop3 = ${prop3}
[echo] user.home = C:\Documents and Settings\ericb
[java] Now in ShowProps class...
[java] prop1 = Property 1 from Buildfile
[java] prop2 = null
[java] prop3 = null
[java] user.home = C:\Documents and Settings\ericb
As you can see, prop3 is undefined in the buildfile because it was not specified on the command
line. The user.home property is available because the Java runtime sets it for us. Once the
demonstration enters the ShowProps class, we see that properties are not automatically propagated
from the Ant buildfile to Java applications. The value for prop1 is available to the ShowProps
application because it was explicitly passed using <sysproperty>.
Here is the output when you type ant -Dprop1="First Prop" -Dprop3="Third
Prop" on the command line:
[echo] Now in buildfile...
[echo] prop1 = First Prop
[echo] prop2 = Property 2 from Buildfile
[echo] prop3 = Third Prop
[echo] user.home = C:\Documents and Settings\ericb
[java] Now in ShowProps class...
[java] prop1 = First Prop
[java] prop2 = null
[java] prop3 = null
[java] user.home = C:\Documents and Settings\ericb
To summarize, this shows how we can pass system properties from the command line to the Ant
buildfile. Once inside the buildfile, we can use <sysproperty> to pass the properties to Java
applications. This is a useful technique because we can use properties to avoid hardcoded values in
buildfiles and Java programs.
3.6.4 See Also
See the JavaDoc for java.lang.System for a list of standard system properties. Use Ant's
echoproperties task to list all properties in the current project.
3.7 Checking for the Existence of Properties
3.7.1 Problem
You want to check for the existence of several properties and/or environment variables before you
perform a build.
3.7.2 Solution
Define a "checkProperties" target that uses the fail task to abort the build if any properties are
undefined.
3.7.3 Discussion
Suppose that various parts of your buildfile require several environment variables. First, specify a
target that checks those properties:
<target name="checkProperties">
<fail unless="env.TOMCAT_HOME">TOMCAT_HOME must be
set</fail>
<fail unless="env.JUNIT_HOME">JUNIT_HOME must be set</fail>
<fail unless="env.JBOSS_HOME">JBOSS_HOME must be set</fail>
</target>
This causes the build to fail if any one of these environment variables is not set. To execute this target,
list it as a dependency from some other target:
<target name="compile" depends="checkProperties">
...
</target>
The dependency ensures that the checkProperties target executes before Ant attempts to
compile your code.
3.7.4 See Also
The previous two recipes showed how to define environment variables and Ant properties.
3.8 Defining a Classpath
3.8.1 Problem
You want to define a classpath and reuse it throughout a buildfile.
3.8.2 Solution
Use the <path> element to define the classpath along with a unique ID. Then refer to the classpath
using the ID.
3.8.3 Discussion
Example 3-5 shows how to define a classpath and refer to it later from the javac task.
Example 3-5. Reusing a classpath
<?xml version="1.0" encoding="UTF-8"?>
<project name="Classpath Sample" default="compile"
basedir=".">
<!-- get an environment variable -->
<property environment="env"/>
<property name="tomcatHome" value="${env.TOMCAT_HOME}"/>
<!-- define some directories -->
<property name="dir.src" value="src"/>
<property name="dir.build" value="build"/>
<property name="dir.lib" value="lib"/>
<!-- Define a classpath for use throughout the buildfile -->
<path id="project.classpath">
<pathelement location="${dir.src}"/>
<!-- include Tomcat libraries -->
<fileset dir="${tomcatHome}/common/lib">
<include name="*.jar"/>
</fileset>
<!-- include our own libraries -->
<fileset dir="${dir.lib}">
<include name="*.jar"/>
</fileset>
</path>
<target name="clean">
<delete dir="${dir.build}"/>
</target>
<target name="prepare">
<mkdir dir="${dir.build}"/>
</target>
<target name="compile" depends="prepare">
<!-- use <pathconvert> to convert the path into a property
-->
<pathconvert targetos="windows" property="windowsPath"
refid="project.classpath"/>
<!-- now echo the path to the console -->
<echo>Windows path = ${windowsPath}</echo>
<!-- Here is how to use the classpath for compiling -->
<javac destdir="${dir.build}">
<src path="${dir.src}"/>
<classpath refid="project.classpath"/>
</javac>
</target>
</project>
Several aspects of this buildfile are worthy of discussion. We define our classpath using the <path>
element, giving it a unique ID so it can be referenced and reused more than once:
<path id="project.classpath">
You can construct a path consisting of many different files using a combination of nested
<pathelement> and <fileset> elements. The first nested <pathelement> in our
example adds the source directory to our path:
<pathelement location="${dir.src}"/>
We then use two <fileset>s to add numerous JAR files to our path:
<fileset dir="${tomcatHome}/common/lib">
<include name="*.jar"/>
</fileset>
<!-- include our own libraries -->
<fileset dir="${dir.lib}">
<include name="*.jar"/>
</fileset>
All of these items are added in the order listed in the buildfile. Later, we use <pathconvert> to
store our path in a property named windowsPath:
<pathconvert targetos="windows" property="windowsPath"
refid="project.classpath"/>
This does not affect the path in any way. Instead, it creates the windowsPath property, which
might contain something like:
C:\myproj\src;C:\tomcat\common\lib\servlet.jar;etc...
This property is useful for debugging purposes because you can echo it to the console for inspection.
Our buildfile concludes by using the classpath with the javac task:
<javac destdir="${dir.build}">
<src path="${dir.src}"/>
<classpath refid="project.classpath"/>
</javac>
Since the classpath has an ID, you can refer to it from other targets throughout the buildfile as shown.
We almost always create a lib directory in source control and put all the JARs
we depend on there. This makes it easy to find the JAR files and update them
in a controlled manner.
3.8.4 See Also
The next two recipes provide additional information about setting up paths.
3.9 Defining Platform-Independent Paths
3.9.1 Problem
You want to define paths that work on Windows, Unix, and other operating systems.
3.9.2 Solution
Define your paths, as shown in Recipe 3.8. Ant takes care of converting the paths to whatever
platform you are running on. Use forward-slashes (/) between directories. Use either semi-colons (;) or
colons (:) between paths; Ant handles both.
3.9.3 Discussion
Ant determines what operating system you are running on and converts paths accordingly. You should
avoid Windows-style drive letters whenever possible; they will not work on Unix. If you must refer to
a drive letter, use a system property as outlined in Recipe 3.6 to avoid hardcoding the path.
Use the pathconvert task to convert an Ant path to native format and store it in a property. Here
is how you define a path and then convert it to Unix format:
<path id="path.test">
<!-- find all unit tests under the build directory -->
<fileset dir="${dir.build}">
<include name="**/Test*.class"/>
</fileset>
</path>
<!-- convert the path to UNIX format, storing it in a
property -->
<pathconvert targetos="unix" property="unixPath"
refid="path.test"/>
3.9.4 See Also
See the Ant user manual for more examples of the pathconvert task.
3.10 Including and Excluding Files
3.10.1 Problem
You want to include and/or exclude certain files and directories from a build.
3.10.2 Solution
Use Ant patterns along with <include> and <exclude> tags, or includes and
excludes attributes.
3.10.3 Discussion
Ant uses a simple pattern syntax for selecting files, which you have undoubtedly seen in other
examples throughout this chapter. Here is how you can use this syntax to include all .java files in a
particular directory:
includes="src/com/oreilly/util/*.java"
Because Java projects are typically divided into numerous packages and subdirectories, you frequently
use the ** wildcard to scan all subdirectories:
includes="src/**/*.java"
This tells Ant to locate all files ending with .java in the src directory and any subdirectories.
In the Ant pattern language, "*" matches any number of characters and "?" matches one character. So
you can locate Test1.java and Test2.java as follows:
includes="Test?.java"
Because "?" matches a single character, TestABC.java is not matched by the preceding pattern.
Patterns can be combined. Table 3-2 shows some additional pattern examples.
Table 3-2. Ant pattern-matching examples
Pattern Matches Does not match
*.java Person.java Person.class
Person*.java Person.java, PersonA.java, PersonBoss.java P.java, BossPerson.java
Test?.java TestA.java Test.java, TestOne.java
**/*.txt a.txt, src/a.txt, src/com/oreilly/b.txt Files not ending in .txt
src/**/*.java src/A.java, src/com/oreilly/File.java B.java, src/com/oreilly/C.class
**/a/** a (if `a' is a filename), build/File.txt, src/a/File.txt a.java, src/b/C.class
3.10.4 See Also
Search for "Directory Based Tasks" in the Ant user manual for a discussion of Ant's pattern matching
syntax.
3.11 Implementing Conditional Logic
3.11.1 Problem
You want to selectively execute portions of a build based on conditional logic.
3.11.2 Solution
Use target dependencies, properties, and the if and unless attributes of the <target> tag.
3.11.3 Discussion
Ant does not support true conditional logic, such as if/then/else. You can, however, execute targets
depending on the state of properties. This target only executes if the xalanInstalled property
is set:
<target name="compile" if="xalanInstalled">
...
</target>
If the property is not set, the target is ignored. You can also specify that a target should execute unless
a property is set:
<target name="installXalan" unless="xalanInstalled">
...
</target>
3.11.4 See Also
Recipe 3.15 shows how to abort the build if a property is not set. This is a form of conditional logic
that is specific to the fail task. See the Ant documentation for the condition task to learn how
to set properties based upon existence of files, classes, or other resources.
3.12 Defining a Consistent Environment
3.12.1 Problem
You want to ensure that all developers on a team are building the project with identical configurations.
3.12.2 Solution
Ant buildfiles should be as self-contained as possible. Any reliance on external resources, such as the
CLASSPATH environment variable, opens the door for different developers to have different
settings.
3.12.3 Discussion
Without tools like Ant, different developers probably use different tools to compile their code. Some
might prefer to work in text editors like Emacs, while others may use IDEs like IntelliJ IDEA or
Borland JBuilder. Each developer probably has her own unique configuration in such an environment.
Regardless of which tools individuals use, every member of a project should be able to compile her
code in a controlled manner before committing changes to a shared repository. Nothing is wrong with
letting developers use the tools they are most comfortable with, but you should use a tool like Ant for
a common baseline.
Here are some specific tips for setting up an Ant buildfile to ensure a consistent build by all
developers:
• The buildfile should not rely on any external CLASSPATH.
• If the build requires third party JAR files, put the correct versions in a shared directory so
each developer builds with the same versions.[2]
[2] We highly recommend you keep JAR files under version control.
• The buildfile itself should be kept under version control.
• Provide a "clean" target that destroys all generated code.
The clean target is essential because it ensures everything will be compiled during the next build.
Ant relies on file timestamps to determine when class files are out of date with respect to source files.
Although this catches most dependencies, it does not handle many semantic dependencies. For
example, you might remove a method from a base class; the base class will recompile, but any derived
classes will not. The compile may succeed (incorrectly) until you perform a clean build and find the
problem.
3.12.4 See Also
Recipe 3.8 shows how to define a classpath.
3.13 Preventing Build Breaks
3.13.1 Problem
You are concerned because developers keep "breaking the build" by checking in broken code to your
version control tool.[3]
[3] A version control tool is something like CVS or Microsoft Visual SourceSafe.
3.13.2 Solution
Adopt a policy in which developers must perform a clean build using Ant before checking in changes
to the source repository. Ask them to run all unit tests, as well.
3.13.3 Discussion
This is largely a project management issue. If your team has an Ant buildfile along with a suite of unit
tests, the build should not be breaking on a routine basis. Understand that people do make mistakes,
such as forgetting to commit some changes to CVS despite having tested their changes.
Each developer should follow these suggestions in order to minimize integration problems:
• Work in pairs. Your partner should encourage you to follow the full testing procedure before
checking in code.
• Work on one problem at a time. Keeping track of dozens of changes for days at a time is a
good way to get out of sync with the rest of the team and introduce build problems.
• Perform a clean build before testing changes.
• Run the entire suite of unit tests before committing changes to the version control tool.
3.13.4 See Also
Chapter 1 and Chapter 2 discuss XP practices such as continuous integration and pair programming.
3.14 Building JAR Files
3.14.1 Problem
You want to build a JAR file.
3.14.2 Solution
Use Ant's jar task.
3.14.3 Discussion
The jar task creates JAR files, as expected. In its simplest form, you specify the name of the new
JAR file along with the directory containing files to add to the archive. All files in the directory
specified by basedir along with subdirectories and files are added:
<jar jarfile="${dir.dist}/oreilly.jar"
basedir="${dir.build}"/>
The jar task tries to be as efficient as possible. Before creating a new JAR, it checks for an existing
archive and compares file timestamps. In our example, oreilly.jar is only created if it does not exist, or
if any of the files in ${dir.build} are newer than oreilly.jar.
This next example refines our operation by only including .class files, unless they are unit tests
matching the Test*.class pattern:
<jar jarfile="${dir.dist}/oreilly.jar"
basedir="${dir.build}"
includes="**/*.class"
excludes="**/Test*.class"/>
The includes and excludes attributes use the ** pattern to represent any subdirectory. Use
nested <fileset> tags for more sophisticated selections:
<jar jarfile="${dir.dist}/oreilly.jar">
<fileset dir="${dir.build}"
includes="**/*.class"
excludes="**/Test*.class"/>
<fileset dir="${dir.src}"
includes="**/*.properties"/>
</jar>
This JAR file consists of all .class files (except for Test*.class) in the build directory tree. It also
contains all .properties files under the source directory tree.
Ant makes it completely trivial to exclude test cases from a production JAR
file—literally, less than one line of text in the build file. Some teams make
their lives quite hard by having a separate source tree for their test classes,
enduring all kinds of IDE gymnastics because they are mortified they might
inflate their production JARs with test cases.
3.14.4 See Also
Recipe 3.10 covers Ant's pattern-matching syntax.
3.15 Installing JUnit
3.15.1 Problem
You need to configure JUnit so you can run your tests using Ant. Although you have added junit.jar to
your classpath, you still see errors.
3.15.2 Solution
You have three possible solutions:
1. Install Ant's optional.jar as well as JUnit's junit.jar in the ANT_HOME/lib directory.
2. Ensure that neither optional.jar nor junit.jar is in the ANT_HOME/lib directory. Then set up a
classpath in your buildfile that includes both JAR files.
3. Ensure that neither optional.jar nor junit.jar is in the ANT_HOME/lib directory. Then set
your CLASSPATH environment variable to include both JAR files.
3.15.3 Discussion
Ant's junit task is implemented by a class named JUnitTask, which is found in the optional.jar
file that ships with the Ant distribution. Ant includes many so-called "optional" tasks, which generally
depend on external libraries in order to function. In the case of the junit task, junit.jar is required.
It is your responsibility to download JUnit and properly configure it to work with Ant.
Class loading problems are common in cases where optional Ant tasks depend on external libraries
such as junit.jar. The Java ClassLoader instance that loads the JUnitTask class must also be
able to load various JUnit classes. For the proper classes to be visible, you must follow one of the
three solutions that were just mentioned.
You generally install Ant's optional.jar in the ANT_HOME/lib directory, so the easiest way to
configure JUnit is to also install junit.jar in ANT_HOME/lib. Example 3-6 shows an Ant buildfile with
an "install.junit" target that automatically installs junit.jar for you. This target can be added to any of
your buildfiles, thus ensuring that JUnit is properly configured to work with Ant.
Example 3-6. Installing JUnit
<project name="Java XP Cookbook" default="compile"
basedir=".">
<property name="dir.build" value="build"/>
<property name="dir.src" value="src"/>
<property environment="env"/>
<path id="classpath.project">
<pathelement path="${dir.build}"/>
</path>
<target name="install.junit">
<fail unless="env.JUNIT_HOME">
The JUNIT_HOME environment variable must be set.
</fail>
<available property="junit.already.installed"
file="${ant.home}/lib/junit.jar"/>
<copy file="${env.JUNIT_HOME}/junit.jar"
todir="${ant.home}/lib"
failonerror="true"/>
<fail unless="junit.already.installed">
junit.jar was not found in ANT_HOME/lib prior to this
build, so it was copied for you. Please try your build
again.
</fail>
</target>
<target name="prepare" depends="install.junit">
<mkdir dir="${dir.build}"/>
</target>
...remainder of buildfile omitted
Our target first ensures that the JUNIT_HOME environment variable is set. If it isn't, the build fails
with an error message. Next, it sets an Ant property junit.already.installed if it finds
that junit.jar is already present under ANT_HOME/lib.
After setting the property, our buildfile goes ahead and copies junit.jar from the JUnit directory to the
Ant directory. If the file already exists, the copy operation does not do anything. If the copy fails, the
build fails. The copy might fail, for example, if your JUNIT_HOME environment variable is set to
some invalid directory.
Finally, our target fails the build if it finds that JUnit was not already installed before it performed the
copy operation:
<fail unless="junit.already.installed">
junit.jar was not found in ANT_HOME/lib prior to this
build, so it was copied for you. Please try your build
again.
</fail>
You may wonder why we fail the build even though we just finished copying junit.jar to the
ANT_HOME/lib directory. We have to abort the build because when the build first started, JUnit was
not already installed. By this time the Ant class loader has already located all of the JAR files in
ANT_HOME/lib, so we must start a new build in order for it to see junit.jar.
Another Technique
Here's another idea for configuring Ant and JUnit. Put ant.jar, optional.jar, and junit.jar in
your project's lib directory, which is under version control so all developers see the same
JAR files. Write your own ant.bat script and place it next to your buildfile. This custom
ant.bat puts just the desired few jars on the classpath, does not include the user's
environment classpath, and invokes Ant. Thus, there is no need to install Ant or JUnit on
the development machine at all.
3.15.4 See Also
Recipe 3.8 shows how to define a classpath.
3.16 Running Unit Tests
3.16.1 Problem
You want to run all of the unit tests in your project using Ant.
3.16.2 Solution
Follow a consistent naming convention for all of your test classes, and then use Ant's junit and
batchtest tasks to locate and run the tests.
3.16.3 Discussion
Writing unit tests is a key XP practice, and Ant makes it easy to run those tests. A well-written
buildfile should provide a target for running all tests in the project with a single command. In Example
3-7, programmers type ant junit to compile everything and then run all of the unit tests.
Example 3-7. Running unit tests
<?xml version="1.0"?>
<project name="Java XP Cookbook" default="compile"
basedir=".">
<property name="dir.build" value="build"/>
<property name="dir.src" value="src"/>
<property environment="env"/>
<path id="classpath.project">
<pathelement path="${dir.build}"/>
</path>
<target name="install.junit">
<fail unless="env.JUNIT_HOME">
The JUNIT_HOME environment variable must be set.
</fail>
<available property="junit.already.installed"
file="${ant.home}/lib/junit.jar"/>
<copy file="${env.JUNIT_HOME}/junit.jar"
todir="${ant.home}/lib"
failonerror="true"/>
<fail unless="junit.already.installed">
junit.jar was not found in ANT_HOME/lib prior to this
build, so it was copied for you. Please try your build
again.
</fail>
</target>
<target name="prepare" depends="install.junit">
<mkdir dir="${dir.build}"/>
</target>
<target name="clean"
description="Remove all generated files.">
<delete dir="${dir.build}"/>
</target>
<target name="compile" depends="prepare"
description="Compile all source code.">
<javac srcdir="${dir.src}" destdir="${dir.build}">
<classpath refid="classpath.project"/>
</javac>
</target>
<target name="junit" depends="compile">
<junit printsummary="on"
fork="false"
haltonfailure="false"
failureproperty="tests.failed"
showoutput="true">
<classpath refid="classpath.project"/>
<formatter type="brief" usefile="false"/>
<batchtest>
<fileset dir="${dir.src}">
<include name="**/Test*.java"/>
</fileset>
</batchtest>
</junit>
<fail if="tests.failed">
*******************************************************
*******************************************************
One or more tests failed. Check the output...
*******************************************************
*******************************************************
</fail>
</target>
</project>
This buildfile includes logic presented earlier in Recipe 3.15 that automatically installs junit.jar to the
ANT_HOME/lib directory. Once this succeeds, we can proceed with the tests.
We use several attributes on the junit task to configure how Ant runs our tests. Table 3-3 outlines
what each of the shown junit attributes means. This is only a subset of the available attributes;
refer to the Ant documentation for a complete list of attributes.
Table 3-3. junit task attributes
Attribute Description
printsummary="on"
Instructs Ant to print a one-line summary for each test
as it runs. We recommend this setting so you get some
sense of progress as your tests run.
fork="false" Run the tests in the same JVM as Ant. This is the
most efficient way to run your tests.
haltonfailure="false" Do not abort the build if a test failure or error occurs.
failureproperty="test.failed" If a test fails, set the "test.failed" Ant property. We
Table 3-3. junit task attributes
Attribute Description
will use this later to display a big error message that
grabs the user's attention.
showoutput="true" Print output from each test to the console.
In addition to XML attributes, the junit task contains several nested elements. The classpath
element, as you might expect, defines where the classes for your tests are found. In this case, we
reference the project-wide classpath defined earlier in the buildfile.
The formatter element defines how test results are formatted:
<formatter type="brief" usefile="false"/>
The available formatter types are brief, plain, and xml. By specifying usefile="false",
we indicate that output should go to the console rather than a file. The brief formatter is the most
concise, providing information about tests that fail. The plain formatter shows statistics for every
test in text format, and the xml formatter is useful for converting test output to other forms such as
HTML. We will see how to use xml output in Recipe 3.18.
Finally, we use a nested batchtest element to select which tests are actually executed:
<batchtest>
<fileset dir="${dir.src}">
<include name="**/Test*.java"/>
</fileset>
</batchtest>
The batchtest element selects a set of files using a specified naming convention. In our case, we
include all files named Test*.java found under the source directory. Once these files are located,
batchtest converts the filenames into Java classnames, passing those to the junit task where
they are executed.
3.16.4 See Also
The next recipe shows how to run a single test, rather than all tests. Ant and JUnit may also be used
for other kinds of tests. For instance, you may provide targets for customer acceptance tests that also
use the JUnit framework.
3.17 Running Specific Tests
3.17.1 Problem
You want to use Ant to run a single test case.
3.17.2 Solution
Use the junit task with a nested test element.
3.17.3 Discussion
Recipe 3.16 showed how to use junit in conjunction with batchtest to run every test in one or
more paths. There may be times, however, when you want to selectively run a single test. For
instance, you might be working on a specific class and don't want to run hundreds of tests for each
change you make. To run a single test using Ant, use the test element instead of batchtest.
Example 3-8 shows how to define a target that runs a specific test.
Example 3-8. Running a single test
<target name="junit2" depends="compile">
<!-- you may override this on the command line:
ant -Dtestcase=com/oreilly/javaxp/junit/TestGame
junit2 -->
<property name="testcase"
value="com/oreilly/javaxp/junit/TestPerson"/>
<junit fork="false">
<classpath refid="classpath.project"/>
<formatter type="plain" usefile="false"/>
<test name="${testcase}"/>
</junit>
</target>
Rather than hardcode the name of the test, our example allows the user to specify the test name on the
Ant command line. This takes advantage of Ant's ability to obtain properties from the command line
using the -D syntax.
3.17.4 See Also
The previous recipe showed how to run all tests.
3.18 Generating a Test Report
3.18.1 Problem
You want to produce a nicely formatted HTML report that summarizes results from all of your tests.
3.18.2 Solution
Use batchtest along with junitreport.
3.18.3 Discussion
In earlier examples, we sent test results directly to the console. In order to format our results as
HTML, we need to first write the test results to a series of XML files. We do this with the following
line:
<formatter type="xml"/>
This causes test results to go to a series of XML files, one per test. The XML files are written to the
directory named by the todir attribute of the junit task or the nested batchtest element.
Once the files are created, junitreport uses XSLT stylesheets to convert the XML files into a
nice HTML report. The complete Ant target is shown in Example 3-9.
Example 3-9. Generating a test report
<target name="junit" depends="compile">
<junit printsummary="on" fork="false" haltonfailure="false">
<classpath refid="classpath.project"/>
<formatter type="xml"/>
<batchtest todir="${dir.build}">
<fileset dir="${dir.src}">
<include name="**/Test*.java"/>
</fileset>
</batchtest>
</junit>
<junitreport todir="${dir.build}">
<fileset dir="${dir.build}">
<include name="TEST-*.xml"/>
</fileset>
<report format="frames" todir="${dir.build}"/>
</junitreport>
<!-- convert an Ant path to a fully-qualified platform
specific path -->
<pathconvert dirsep="/" property="reportUrl">
<path>
<pathelement location="${dir.build}/index.html"/>
</path>
</pathconvert>
<!-- launch a web browser to view the results -->
<exec executable="cmd" os="Windows XP">
<arg value="/C"/>
<arg value="${reportUrl}"/> <!-- the full path to the
report -->
</exec>
</target>
Our buildfile runs all tests in the src directory tree and then sends XML results to the build directory,
which was specified in the todir attribute of junitreport. After junitreport runs, we
launch a web browser to view the test results. This last portion of the example only works on
Microsoft Windows. If you are on a different platform, simply change the exec task to point to your
browser.
3.18.4 See Also
The previous two recipes show other ways to run tests.
3.19 Checking Out Code from CVS
3.19.1 Problem
You want your Ant buildfile to check out code from CVS before compiling.
3.19.2 Solution
Use Ant's cvs task.
3.19.3 Discussion
You can use the cvs Ant task to execute any CVS command. In order for this to work, you must have
installed the cvs executable on your system path. If Ant does not find cvs, it issues an error and the
build fails.
By default, the cvs task executes a checkout command. Here is the syntax to checkout the
cookbook module from CVS:
<cvs cvsroot="${cvsroot}"
package="cookbook"/>
You can also execute any other CVS command, such as update as shown here:
<cvs command="update -dP"
cvsroot="${cvsroot}"
dest="cookbook"/>
This tells CVS to update the most recent files in the cookbook directory, creating missing directories
and pruning empty directories.
If cvsroot is not specified, the already-defined CVS root from the checked
out project is used.
3.19.4 See Also
See the CVS documentation for information about all of the CVS commands.
3.20 Bootstrapping a Build
3.20.1 Problem
You want to use Ant to kick off a nightly build process.
3.20.2 Solution
Create a "bootstrap" buildfile that checks out a clean copy of all sources from revision control. Then,
pass off control to the main buildfile that was one of the files just checked out.
3.20.3 Discussion
Many projects set up a build server that performs complete, clean builds at scheduled times. A clean
build ensures that every file in the system compiles. If you do not start with a clean slate, you may end
up with a successful build just because some obsolete source or class files are lingering in your
directory structure.
A clean build consists of the following high-level steps:
1. Start the build with a scheduling mechanism of some sort. This is generally platform-specific
and is not covered here.
2. Use a script to checkout all files into a clean directory. This is what we are covering in this
recipe.
3. Once all files are checked out, including the main project buildfile, invoke Ant on the main
buildfile.
Example 3-10 shows the complete Ant buildfile for performing a bootstrap build. The buildfile uses
the cvs task as shown in Recipe 3.19 to checkout or update the entire cookbook directory. Once the
latest files are obtained, we invoke Ant on cookbook/build.xml to perform the clean build.
Example 3-10. Bootstrap buildfile
<?xml version="1.0"?>
<project name="Java XP Cookbook" default="build" basedir=".">
<target name="prepare">
<!-- convert the CVS repository directory into
a fully-qualitied Windows directory -->
<pathconvert targetos="windows"
property="cvsrepository.path">
<path>
<pathelement location="repository"/>
</path>
</pathconvert>
<!-- store the CVS root in a property -->
<property name="cvsroot"
value=":local:${cvsrepository.path}"/>
<!-- determine if the files have been checked out -->
<available file="cookbook" type="dir"
property="already.checked.out"/>
</target>
<target name="clean"
description="Remove the entire cookbook directory.">
<delete dir="cookbook"/>
</target>
<target name="cvscheckout" depends="prepare"
unless="already.checked.out">
<cvs cvsroot="${cvsroot}"
package="cookbook"/>
</target>
<target name="cvsupdate" depends="prepare"
if="already.checked.out">
<cvs command="update -dP"
cvsroot="${cvsroot}"
dest="cookbook"/>
</target>
<target name="build" depends="cvscheckout,cvsupdate">
<ant dir="cookbook" target="all" inheritAll="false"/>
</target>
</project>
3.20.4 See Also
Windows users can use "Scheduled Tasks" under the Control Panel to schedule builds for certain
times of day. The CruiseControl tool is designed to help with continuous integration, and is available
at http://cruisecontrol.sourceforge.net.
Chapter 4. JUnit
Section 4.1. Introduction
Section 4.2. Getting Started
Section 4.3. Running JUnit
Section 4.4. assertXXX( ) Methods
Section 4.5. Unit Test Granularity
Section 4.6. Set Up and Tear Down
Section 4.7. One-Time Set Up and Tear Down
Section 4.8. Organizing Tests into Test Suites
Section 4.9. Running a Test Class Directly
Section 4.10. Repeating Tests
Section 4.11. Test Naming Conventions
Section 4.12. Unit Test Organization
Section 4.13. Exception Handling
Section 4.14. Running Tests Concurrently
Section 4.15. Testing Asynchronous Methods
Section 4.16. Writing a Base Class for Your Tests
Section 4.17. Testing Swing Code
Section 4.18. Avoiding Swing Threading Problems
Section 4.19. Testing with the Robot
Section 4.20. Testing Database Logic
Section 4.21. Repeatedly Testing the Same Method
4.1 Introduction
Unit testing is at the heart of XP, and it is a central theme of this book. JUnit,[1] available from
http://www.junit.org, is the de facto standard for Java unit testing. It is a simple framework for
creating automated unit tests. JUnit test cases are Java classes that contain one or more unit test
methods, and these tests are grouped into test suites. You can run tests individually, or you can run
entire test suites.
[1] We cover JUnit Version 3.8.1 in this chapter.
Ant includes the junit task for running JUnit tests. We show how to run
JUnit tests using Ant in Chapter 3.
Each JUnit test method should execute quickly. Speed is important because as more tests are written
and integrated into the build process, it takes longer to run the entire test suite. Programmers do not
want to be interrupted for long periods of times while tests run—so the longer the tests take to execute
the greater the likelihood programmers will skip this critical phase.
You can also increase the likelihood that programmers will run the tests by making it extremely easy,
preferably with a single command. The ability to run all tests with a single command or button click is
nearly a requirement to claim that your project is doing XP. We showed how to run tests with Ant in
the previous chapter, and many IDEs now make it possible to run tests by clicking on a menu item.
JUnit tests are pass/fail tests explicitly designed to run without human intervention. Because of this
design, you can (and should) add your test suite to your continuous integration build process so the
tests run automatically.
4.2 Getting Started
4.2.1 Problem
You want to write unit tests with JUnit.
4.2.2 Solution
Create a subclass of junit.framework.TestCase. Each unit test is represented by a
testXXX( ) method within the TestCase subclass.
4.2.3 Discussion
Example 4-1 shows an extremely simple test case. A test case is a subclass of TestCase and
contains a collection of unit tests. Instances of TestCase are sometimes referred to as test fixtures,
although we prefer to say "test case" since that matches the class name. Each unit test is a public, noargument
method beginning with "test". If you do not follow this naming convention, JUnit will not
be able to locate your test methods automatically. Instead, you would have to write a suite( )
method and construct instances of your test case, passing the test method name to the constructor.
Example 4-1. Simple test case
package com.oreilly.javaxp.common;
import junit.framework.TestCase;
/**
* Sample unit tests for the {@link Person} class.
*/
public class TestPerson extends TestCase {
/**
* This constructor is only required in JUnit 3.7 and
earlier.
* @param testMethodName the name of the test method to
execute.
*/
public TestPerson(String testMethodName) {
super(testMethodName);
}
/**
* A unit test to verify the name is formatted correctly.
*/
public void testGetFullName( ) {
Person p = new Person("Aidan", "Burke");
assertEquals("Aidan Burke", p.getFullName( ));
}
/**
* A unit test to verify that nulls are handled properly.
*/
public void testNullsInName( ) {
Person p = new Person(null, "Burke");
assertEquals("? Burke", p.getFullName( ));
// this code is only executed if the previous
assertEquals passed!
p = new Person("Tanner", null);
assertEquals("Tanner ?", p.getFullName( ));
}
}
In JUnit 3.7 and earlier, the constructor is required and must have the signature shown in the
TestPerson class. JUnit uses this constructor to create a new instance of the test case as it runs
each of the unit test methods. The name argument matches the current unit test's method name,
allowing JUnit to use reflection to invoke the corresponding method. JUnit 3.8 removed the need for
this constructor, so we will not include it in the remaining examples in this chapter.
The "test" methods are the actual unit tests. You must have at least one unit test in each test case or
JUnit reports an error. Our TestPerson class has two unit tests, each of which checks different
aspects of the Person class's getFullName( ) method. Test methods should[2] follow this
signature:
[2] You could adopt a different naming convention; however, JUnit would not automatically find your test
methods. You would have to build your test suite manually by constructing instances of your test case,
passing your method names to the constructor.
public void test<something>( ) [throws SomeException]
This naming convention allows JUnit to locate unit tests by reflection. Tests may throw any subclass
of java.lang.Throwable. When this happens, JUnit catches the exception and reports a test
error. It continues to execute any additional test methods.
Each unit test uses various assertXXX( ) methods to do the actual testing:
assertEquals("Aidan Burke", p.getFullName( ));
This method confirms that its two arguments are equal. If the arguments are equal, the test passes.
Otherwise, a test failure is reported and the remainder of the current test method is skipped. JUnit does
proceed to execute other test methods, however. In the case of Object arguments (such as two
Strings), the .equals( ) method is used for checking equality.
To compile TestPerson, include junit.jar in your classpath. The next recipe shows how to run the
tests.
4.2.4 See Also
Recipe 4.3 shows how to run your tests. Recipe 4.4 explains the assert( ) methods. Recipe 4.5
describes how fine-grained your tests should be.
4.3 Running JUnit
4.3.1 Problem
You want to run your tests.
4.3.2 Solution
We have already demonstrated how to run JUnit using Ant, back in Chapter 3. In order to run tests
from a script or in an IDE, include junit.jar in your classpath and then use the
junit.textui.TestRunner class to run your tests in text mode. Use
junit.swingui.TestRunner to run the tests in a Swing GUI.[3]
[3] Use junit.awtui.TestRunner for an older, AWT-based test runner.
4.3.3 Discussion
JUnit can run tests in text or graphical mode. Text mode is faster, and is excellent for running tests as
part of an automated build process. Graphical tests are more interesting to run, and can make it easier
to analyze output from a large number of tests.
4.3.3.1 Text testing
Here's an example session using the text-based TestRunner. The first line is typed at the prompt;
the rest is output. The TestPerson class is the test case from the previous recipe.
java junit.textui.TestRunner
com.oreilly.javaxp.junit.TestPerson
.F.F
Time: 0.02
There were 2 failures:
1)
testGetFullName(com.oreilly.javaxp.junit.TestPerson)junit.fram
ework.
AssertionFailedError: expected:<Aidan Burke> but
was:<AidanBurke>
at
com.oreilly.javaxp.junit.TestPerson.testGetFullName(C:/cvsdata
/java_xp_
cookbook/examples/src/com/oreilly/javaxp/junit/TestPerson.java
:24)
2)
testNullsInName(com.oreilly.javaxp.junit.TestPerson)junit.fram
ework.
AssertionFailedError: expected:<? Burke> but was:<?Burke>
at
com.oreilly.javaxp.junit.TestPerson.testNullsInName(C:/cvsdata
/java_xp_
cookbook/examples/src/com/oreilly/javaxp/junit/TestPerson.java
:29)
FAILURES!!!
Tests run: 2, Failures: 2, Errors: 0
The first line of output shows a dot (.) as each test runs. Once you have dozens or hundreds of tests,
the dots allow you to see that tests are progressing. JUnit also shows "F" for each failure:
.F.F
JUnit displays the cumulative time (in seconds), followed by a summary report of failures and errors.
Both unit tests failed. The expected text didn't match the existing text:
expected:<Aidan Burke> but was:<AidanBurke>
Either our test is incorrect, or the Person class failed to insert a space between the first and last
names. It's the latter.. The final line shows cumulative totals from the unit tests:
Tests run: 2, Failures: 2, Errors: 0
This indicates that a total of two tests ran, and both had failures. No tests had errors.
A test failure occurs when an assertXXX( ) statement fails. A test error
occurs when a unit test throws an exception.
After fixing the Person class, we can run the tests again. We see the following output:
java junit.textui.TestRunner
com.oreilly.javaxp.junit.TestPerson
..
Time: 0.01
OK (2 tests)
4.3.3.2 Graphical testing
While text-mode testing is great for automated testing, it can be more interesting to watch your tests
graphically, as in Figure 4-1. Here is the command to run the GUI:
java junit.swingui.TestRunner
com.oreilly.javaxp.junit.TestPerson
Figure 4-1. The JUnit Swing GUI
The black-and-white figure does not illustrate the fact that the progress bar near the top of the screen
is red, indicating one or more errors or failures. As the tests run, the progress bar fills from left to
right.
The output is essentially the same as JUnit's text UI; however, you can click on lines to see the
message associated with each problem. This is a particular advantage of the graphical TestRunner
when you have to sift through large numbers of problems.
Figure 4-2 shows the Test Hierarchy tab. This tab allows you to see which of the unit tests passed or
failed, and allows you to re-run individual tests.
Figure 4-2. Test Hierarchy tab
Figure 4-3 shows the output once all bugs are fixed and every test passes. You cannot tell, but the
progress bar is now green.
Figure 4-3. All tests pass
4.3.3.3 Reload classes every run
On a final note, the JUnit GUI provides a checkbox allowing you to "Reload classes every run." When
checked, the JUnit ClassLoader reads the latest .class files for your tests each time they are run.
This allows you to leave the GUI up while you recompile your source code. The new classes are
loaded the next time you click the Run button.
4.3.4 See Also
Most Java IDEs are integrated with JUnit. Read your IDE documentation to learn how to run tests
directly within the IDE. See Recipe 4.4 to learn how to provide more descriptive error messages.
Chapter 3 shows how to run JUnit using Ant.
4.4 assertXXX( ) Methods
4.4.1 Problem
You want to use the various assertXXX( ) methods to test different conditions.
4.4.2 Solution
junit.framework.TestCase, the base class for all test cases, extends from
junit.framework.Assert, which defines numerous overloaded assertXXX( )
methods. Your tests function by calling these methods.
4.4.3 Discussion
Table 4-1 summarizes the various assertXXX( ) methods that can be found in
junit.framework.Assert. Although you could get by with using assertTrue( ) for
nearly every test, using one of the more specific assertXXX( ) methods often makes your tests
more understandable and provides good failure messages. This table is only a summary; each of the
methods is overloaded as described shortly.
Table 4-1. Assert method summary
Method Description
assert( )
This was deprecated in JUnit 3.7 because it interferes with the J2SE 1.4
assert keyword. You should use assertTrue( ) instead. This
method was completely removed in JUnit 3.8.
assertEquals(
) Compares two values for equality. The test passes if the values are equal.
assertFalse( ) Evaluates a boolean expression. The test passes if the expression is false.
assertNotNull(
)
Compares an object reference to null. The test passes if the reference is
not null.
assertNotSame(
)
Compares the memory address of two object references using the ==
operator. The test passes if both refer to different objects.
assertNull( ) Compares an object reference to null. The test passes if the reference is
null.
assertSame( ) Compares the memory address of two object references using the ==
operator. The test passes if both refer to the same object.
assertTrue( ) Evaluates a boolean expression. The test passes if the expression is true.
fail( ) Causes the current test to fail. This is commonly used with exception
handling, as shown in Recipe 4.13.
4.4.3.1 Optional first argument
All of the methods in Table 4-1 are overloaded to accept an optional String as the first argument.
When specified, this argument provides a descriptive message should the test fail. Here is an example
that shows two assert statements, one with the description and one without:
assertEquals(employeeA, employeeB);
assertEquals("Employees should be equal after the clone( )
operation.",
employeeA, employeeB);
The second version is preferable because it describes why the test failed, making it easier to fix
problems down the road.
The message should describe what is asserted to be true, rather than what went
wrong.
4.4.3.2 Equality comparison
The assertSame( ) method compares two object references, ensuring that they both refer to the
same memory address. assertSame( ) uses the == operator for its comparison. The following
two tests are functionally identical:
assertSame("Expected the two parts to be identical.", part1,
part2);
assertTrue("Expected the two parts to be identical.", part1 ==
part2);
While assertSame( ) compares memory addresses, assertEquals( ) compares
contents. For objects, this means the .equals( ) method is used instead of ==.
assertEquals( ) has numerous overloaded implementations that compare objects to other
objects, or primitives to other primitives. Regardless of what you are comparing, the expected value is
always listed before the actual value you are testing against. Here are a few examples:
// compare two objects (not using the description argument)
assertEquals(expectedBirthDate, son.getBirthDate( ));
assertEquals("Garrett", son.getMiddleName( ));
// compare primitives
assertEquals(50, race.getNumLaps( ));
assertEquals('a', car.getIdentifier( ));
assertEquals(expectedByte, customer.getCategory( ));
JUnit provides special assertEquals( ) methods comparing doubles and floats. These
methods accept a delta argument, allowing for rounding off errors. Here is how you can verify that the
temperature is 97.1 degrees, accurate to within 0.001 degrees:
assertEquals("Temperature", expectedTemp, actualTemp, 0.001);
4.4.3.3 Additional examples
Here is how you check for a Boolean condition:
assertTrue("Expected the temperature to be non-negative.",
actualTemp >= 0);
Prior to JUnit 3.8, you had to adjust your tests slightly to check for false conditions:
assertTrue("The car should not be running.", !car.isRunning(
));
JUnit 3.8 added the assertFalse( ) method, making the test more clear:
assertFalse("The car should not be running.", car.isRunning(
));
Checking for null is easy:
assertNull("Did not expect to find an employee.",
database.getEmployee("someInvalidEmployeeId"));
You can also check for non-null values:
assertNotNull("Expected to find an employee with id=" + id,
database.getEmployee(id));
And finally, you can explicitly cause a test failure using the fail( ) method:
fail("Unable to configure database.");
4.4.4 See Also
See the JavaDocs for junit.framework.Assert. The methods in Assert are all static, and
can be called from other classes. See Recipe 6.3 for an example.
4.5 Unit Test Granularity
4.5.1 Problem
You want to know how fine-grained your unit tests should be.
4.5.2 Solution
Each unit test should check one specific piece of functionality. Do not combine multiple, unrelated
tests into a single testXXX( ) method.
4.5.3 Discussion
Each test method can have as many assertXXX( ) calls as you like, but they can lead to
problems:
public void testGame( ) throws BadGameException {
Game game = new Game( );
Ship fighter = game.createFighter("001");
assertEquals("Fighter did not have the correct
identifier",
"001", fighter.getId( ));
Ship fighter2 = game.createFighter("001");
assertSame("createFighter with same id should return same
object",
fighter, fighter2);
assertFalse("A new game should not be started yet",
game.isPlaying( ));
}
This is a bad design because each assertXXX( ) method is testing an unrelated piece of
functionality. If the first assertEquals( ) fails, the remainder of the test is not executed. When
this happens, you won't know if the other tests are functional.
Example 4-2 shows a refactored test case that tests various aspects of our game independently. We
will see how to remove the duplicated code in Recipe 4.6 when we talk about setUp( ) and
tearDown( ).
Example 4-2. Refactored tests
public void testCreateFighter( ) throws BadGameException {
Game game = new Game( );
Ship fighter = game.createFighter("001");
assertEquals("Fighter did not have the correct
identifier",
"001", fighter.getId( ));
game.shutdown( );
}
public void testSameFighters( ) throws BadGameException {
Game game = new Game( );
Ship fighter = game.createFighter("001");
Ship fighter2 = game.createFighter("001");
assertSame("createFighter with same id should return same
object",
fighter, fighter2);
game.shutdown( );
}
public void testGameInitialState( ) throws BadGameException {
Game game = new Game( );
assertFalse("A new game should not be started yet",
game.isPlaying( ));
game.shutdown( );
}
With this approach, one test failure will not cause the remaining assertXXX( ) statements to be
skipped.
This issue raises the question: should a test method ever contain more than one assertXXX( )?
The answer is a definite yes! If you are testing a series of conditions in which subsequent tests will
always fail when the first fails, you may as well combine all of the asserts in one test.
4.5.4 See Also
See Recipe 4.6 to learn how to create the Game object in the setUp( ) method and shutdown the
game in the tearDown( ) method.
4.6 Set Up and Tear Down
4.6.1 Problem
You want to avoid duplicated code when several tests share the same initialization and cleanup code.
4.6.2 Solution
Use the setUp( ) and tearDown( ) methods. Both of these methods are part of the
junit.framework.TestCase class.
4.6.3 Discussion
JUnit follows a very specific sequence of events when invoking tests. First, it constructs a new
instance of the test case for each test method. Thus, if you have five test methods, JUnit constructs
five instances of your test case. For this reason, instance variables cannot be used to share state
between test methods. After constructing all of the test case objects, JUnit follows these steps for each
test method:
• Calls the test case's setUp( ) method
• Calls the test method
• Calls the test case's tearDown( ) method
This process repeats for each of the test methods in the test case. Example 4-3 shows how you can
take advantage of setUp( ) and tearDown( ) to avoid duplicated code.
Example 4-3. setUp( ) and tearDown( )
package com.oreilly.javaxp.junit;
import com.oreilly.javaxp.common.BadGameException;
import com.oreilly.javaxp.common.Game;
import com.oreilly.javaxp.common.Ship;
import junit.framework.TestCase;
/**
* Sample unit tests for the {@link Game} class.
*/
public class TestGame extends TestCase {
private Game game;
private Ship fighter;
public void setUp( ) throws BadGameException {
this.game = new Game( );
this.fighter = this.game.createFighter("001");
}
public void tearDown( ) {
this.game.shutdown( );
}
public void testCreateFighter( ) {
assertEquals("Fighter did not have the correct
identifier",
"001", this.fighter.getId( ));
}
public void testSameFighters( ) {
Ship fighter2 = this.game.createFighter("001");
assertSame("createFighter with same id should return
same object",
this.fighter, fighter2);
}
public void testGameInitialState( ) {
assertTrue("A new game should not be started yet",
!this.game.isPlaying( ));
}
}
You can often ignore the tearDown( ) method because individual unit tests are not long-running
processes, and objects are garbage-collected as soon as the JVM exits. tearDown( ) can be
useful, however, if your tests do things like open database connections, show GUI frames, or consume
other sorts of system resources that you would like to clean up immediately. If you are running a large
suite of unit tests, setting references to null in your tearDown( ) methods may help the
garbage collector reclaim memory as other tests run.
You may be wondering why you should write a setUp( ) method instead of simply initializing
fields in a test case's constructor. After all, since a new instance of the test case is created for each of
its test methods, the constructor is always called before setUp( ). In a vast majority of cases, you
can use the constructor instead of setUp( ) without any side effects.
In cases where your test case is part of a deeper inheritance hierarchy, you may wish to postpone
object initialization until instances of derived classes are fully constructed. This is a good technical
reason why you might want to use setUp( ) instead of a constructor for initialization. Using
setUp( ) and tearDown( ) is also good for documentation purposes, simply because it may
make the code easier to read.
4.6.4 See Also
Recipe 4.7 shows how to set up data once for a whole series of tests.
4.7 One-Time Set Up and Tear Down
4.7.1 Problem
You want to run some setup code one time and then run several tests. You only want to run your
cleanup code after all of the tests are finished.
4.7.2 Solution
Use the junit.extensions.TestSetup class.
4.7.3 Discussion
As outlined in Recipe 4.6, JUnit calls setUp( ) before each test, and tearDown( ) after each
test. In some cases you might want to call a special setup method once before a series of tests, and
then call a teardown method once after all tests are complete. The
junit.extensions.TestSetup class supports this requirement. Example 4-4 shows how to
use this technique.
Example 4-4. One-time set up and tear down
package com.oreilly.javaxp.junit;
import com.oreilly.javaxp.common.Person;
import junit.extensions.TestSetup;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
public class TestPerson extends TestCase {
public void testGetFullName( ) { ... }
public void testNullsInName( ) { ... }
public static Test suite( ) {
TestSetup setup = new TestSetup(new
TestSuite(TestPerson.class)) {
protected void setUp( ) throws Exception {
// do your one-time setup here!
}
protected void tearDown( ) throws Exception {
// do your one-time tear down here!
}
};
return setup;
}
}
TestSetup is a subclass of junit.extensions.TestDecorator, which is a base class
for defining custom tests. The main reason for extending TestDecorator is to gain the ability to
execute code before or after a test is run.[4] The setUp( ) and tearDown( ) methods of
TestSetup are called before and after whatever Test is passed to its constructor. In our example
we pass a TestSuite to the TestSetup constructor:
[4] JUnit includes source code. Check out the code for TestSetup to learn how to create your own
extension of TestDecorator.
TestSetup setup = new TestSetup(new
TestSuite(TestPerson.class)) {
This means that TestSetup's setUp( ) method is called once before the entire suite, and
tearDown( ) is called once afterwards. It is important to note that the setUp( ) and
tearDown( ) methods within TestPerson are still executed before and after each individual
unit test method within TestPerson.
4.7.4 See Also
Recipe 4.6 describes setUp( ) and tearDown( ).
4.8 Organizing Tests into Test Suites
4.8.1 Problem
You want to organize multiple tests into a suite of tests, all of which run at once.
4.8.2 Solution
JUnit does this automatically for each test case. You can construct an instance of
junit.framework.TestSuite to create your own suites manually.
4.8.3 Discussion
When you use the text or graphical test runner, JUnit looks for the following method in your test
case:[5]
[5] The Ant junit task also looks for the suite() method.
public static Test suite( ) { ... }
If the method is not found, JUnit uses reflection to automatically locate all testXXX( ) methods
in your test case, adding them to a suite of tests. It then runs all tests in this suite. You can duplicate
the default suite( ) behavior as follows:
public class TestGame extends TestCase {
...
public static Test suite( ) {
return new TestSuite(TestGame.class);
}
}
By passing the TestGame.class object to the TestSuite constructor, you are telling JUnit
to locate all of the testXXX( ) methods in that class and add them to the suite. This code does not
do anything above and beyond what JUnit does automatically, but there are more interesting ways to
use the TestSuite class. For instance, you can add individual tests to only run certain tests, or you
can control the order in which they are executed:
public static Test suite( ) {
TestSuite suite = new TestSuite( );
// To use this idiom, you must define the String
constructor in your
// TestGame class. Remember that JUnit 3.8 made that
constructor optional.
suite.addTest(new TestGame("testCreateFighter"));
suite.addTest(new TestGame("testSameFighters"));
return suite;
}
Or, even better, you can compose multiple suites into other suites. You might recognize this as the
Composite design pattern.[6]
[6] See Gamma et al., Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley).
For example:
public static Test suite( ) {
TestSuite suite = new TestSuite(TestGame.class);
suite.addTest(new TestSuite(TestPerson.class));
return suite;
}
Now, when you run this test case, you will run all tests from both TestGame and TestPerson.
4.8.4 See Also
Recipe 4.12 provides suggestions for organizing test suites.
4.9 Running a Test Class Directly
4.9.1 Problem
You don't want to invoke one of the JUnit test runners. Instead, you would like to run your test
directly.
4.9.2 Solution
Add a main( ) method to your test case. Or, use Ant to run your tests as discussed in Chapter 3.
4.9.3 Discussion
Adding a main( ) method can make a class easier to run. Most IDEs allow you to click on a class
and select some sort of "run" option from a popup menu, provided the class has a main( ) method.
Here is a sample main( ) method for our TestGame class:
public class TestGame extends TestCase {
...
public static void main(String[] args) {
junit.textui.TestRunner.run(new
TestSuite(TestGame.class));
}
}
When executed, this method runs the test suite in text mode. Output is sent to the console.
4.9.4 See Also
Recipe 4.3 shows how to run unit tests. Chapter 3 shows how to run tests using Ant.
4.10 Repeating Tests
4.10.1 Problem
You want to run certain tests repeatedly.
4.10.2 Solution
Use the junit.extensions.RepeatedTest class.
4.10.3 Discussion
You may want to run certain tests repeatedly to measure performance or to diagnose intermittent
problems.[7] The RepeatedTest class makes this easy:
[7] Threading bugs are often intermittent.
public static Test suite( ) {
// run the entire test suite ten times
return new RepeatedTest(new TestSuite(TestGame.class),
10);
}
RepeatedTest's first argument is another Test to run; the second argument is the number of
iterations. Since TestSuite implements the Test interface, we can repeat the entire test as just
shown. Here is how you can build a test suite where different tests are repeated differently:
TestSuite suite = new TestSuite( );
// repeat the testCreateFighter test 100 times
suite.addTest(new RepeatedTest(new
TestGame("testCreateFighter"), 100));
// run testSameFighters once
suite.addTest(new TestGame("testSameFighters"));
// repeat the testGameInitialState test 20 times
suite.addTest(new RepeatedTest(new
TestGame("testGameInitialState"), 20));
4.10.4 See Also
Recipe 4.14 shows more examples of RepeatedTest.
4.11 Test Naming Conventions
4.11.1 Problem
You want to define a naming convention for your tests.
4.11.2 Solution
Prefix each test case classname with a consistent word, such as "Test" or "UnitTest". Put test cases in
the same directory as the classes they are testing.
4.11.3 Discussion
Consistent naming conventions serve two purposes. First, they make your code more maintainable.
Second, consistency facilitates automation. The tests in this chapter are prefixed with "Test", resulting
in names like TestGame, TestPerson, and TestAccount. These correspond to the Game,
Person, and Account classes, respectively.
Writing one test case per class makes it very easy to glance at a directory and see which tests are
available. Putting "Test" at the beginning of the filenames makes sorting easier, in our opinion,
particularly when your IDE provides some sort of jump-to functionality.[8] All tests will be grouped
together and easy to identify. On the other hand, putting "Test" at the end of the filenames does make
it easier to identify which classes do not have tests.
[8] IntelliJ IDEA (http://www.intellij.com) allows you to hit Ctrl-N and then begin typing a classname. If you
follow the prefix convention, you immediately see a list of all tests as soon as you type Test.
Another popular convention is to place all test classes in a parallel directory
structure. This allows you to use the same Java package names for your tests,
while keeping the source files separate. To be honest, we do not like this
approach because you must look in two different directories to find files. Ant
can easily exclude tests from your build even if they reside in the same source
directory.
Finally, a consistent naming convention makes it easier to locate tests when using Ant for your builds.
You might want to exclude all of your tests when you create a production build of your software. You
can do this in Ant as follows:
<javac destdir="${dir.build}">
<src path="${dir.src}"/>
<!-- see how easy it is to exclude the tests from a build! -
->
<exclude name="**/Test*.java"/>
</javac>
Prefix or Postfix?
We prefer to prefix "Test" onto the beginning of our test classnames, while many other
people prefer to postfix "Test" onto the end. The main argument for postfixing names is that
Customer.java and CustomerTest.java appear next to each other when sorting files within a
directory. This makes it easy to identify which classes have tests.
We use the prefix convention because it makes searching easier within our IDE. We
recommend you use the approach you prefer consistently. Remember that Ant relies on a
consistent filenaming convention to locate tests.
4.11.4 See Also
Recipe 3.16 shows how to run tests using Ant based on naming conventions. Recipe 3.14 shows how
to exclude test classes from a build.
4.12 Unit Test Organization
4.12.1 Problem
You want to organize all of your tests consistently.
4.12.2 Solution
Create a test case that runs all tests in the current package and subpackages. Duplicate this pattern for
all packages in your application.
Some Java IDEs allow you to automatically run all tests in your project or in a
specific package, negating the need for this recipe.
4.12.3 Discussion
Example 4-5 shows an example of the technique outlined in the solution just presented. It runs all of
the test suites in the current package as well as delegating to each AllTests class in immediate
subpackages.
Example 4-5. AllTests example
package com.oreilly.javaxp.junit;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;
/**
* Runs all test suites in the current package and subpackages.
*/
public class AllTests extends TestCase {
/**
* @return a suite containing all tests in this package
* and subpackages.
*/
public static Test suite( ) {
TestSuite suite = new TestSuite( );
// add tests from the current directory. This requires
manual
// updates, which is the main weakness of this
technique
suite.addTest(new TestSuite(TestGame.class));
suite.addTest(new TestSuite(TestPerson.class));
// add AllTests from any sub-packages
suite.addTest(com.oreilly.javaxp.junit.sub.AllTests.suite(
));
// suite.addTest(...) // continue for other subpackages
return suite;
}
}
This technique can be useful when using an IDE[9] because you can select any AllTests class and
run tests for a subset of your project. Assuming that you follow this pattern consistently, you can run
the AllTests in your root directory to run every test in your application.
[9] IntelliJ IDEA allows you to right-click on any directory and run all tests in that package, thus eliminating the
need to manually create an AllTests class.
AllTests intentionally avoids the TestXXX naming convention outlined in
Recipe 4.11. This prevents the AllTests from being executed when you tell Ant
to find and run all TestXXX classes.
Human fallibility is the main weakness of this technique. If you are not diligent, you will forget to add
some tests to one of the AllTests classes. This can be overcome by writing a utility to
automatically generate the AllTests classes. Yet another technique is to do the same thing
dynamically: to write a class that sifts through a directory/package looking for TestXXXX classes
and including them in the suite.
You might also want to consider whether the AllTests classes should run tests in subpackages, or
just the current package. Here is a modification that allows you to choose the behavior you want based
on a system property:
public static Test suite( ) {
TestSuite suite = new TestSuite( );
// add tests from the current directory
suite.addTest(new TestSuite(TestGame.class));
suite.addTest(new TestSuite(TestPerson.class));
// only test subdirectories if a system property is true
if ("true".equals(System.getProperty("test.subdirs"))) {
// add AllTests from any sub-packages
suite.addTest(com.oreilly.javaxp.junit.sub.AllTests.suite(
));
// suite.addTest(...) // continue for other subpackages
}
return suite;
}
4.12.4 See Also
Recipe 3.16 shows an example of Ant's batchtest element.
4.13 Exception Handling
4.13.1 Problem
You want to test for exceptions.
4.13.2 Solution
Use a try/catch block to catch the expected exception. Call the fail( ) method if the
exception does not occur.
4.13.3 Discussion
In the following example, the Person constructor should throw an
IllegalArgumentException if both of its arguments are null. The test fails if it does not
throw this exception.
public void testPassNullsToConstructor( ) {
try {
Person p = new Person(null, null);
fail("Expected IllegalArgumentException when both args
are null");
} catch (IllegalArgumentException expected) {
// ignore this because it means the test passed!
}
}
Only use this technique when you are expecting an exception. For other error conditions, let the
exception propagate to JUnit. It will catch the exception and report a test error. Here is something you
do not want to do:
// don't do this!
public void testBadStyle( ) {
try {
SomeClass c = new SomeClass( );
c.doSomething( );
...
} catch (IOException ioe) {
fail("Caught an IOException");
} catch (NullPointerException npe) {
fail("Caught a NullPointerException");
}
}
The main problem is that JUnit already catches unhandled errors, so you are doing unnecessary work.
The extra try/catch code adds complexity to your tests, making them harder to maintain. The
previous example is much simpler when written like this:
// must declare IOException because it is not a
RuntimeException
public void testGoodStyle( ) throws IOException {
SomeClass c = new SomeClass( );
c.doSomething( );
...
}
4.14 Running Tests Concurrently
4.14.1 Problem
You want to run several tests concurrently using threads.
4.14.2 Solution
Use the junit.extensions.ActiveTestSuite class to build a suite of tests that run
concurrently.
4.14.3 Discussion
The ActiveTestSuite class runs each of its tests in a separate thread. The suite does not finish
until all of the test threads are complete. Example 4-6 shows how to run three different test methods in
three different threads.
Example 4-6. Running tests in different threads
public static Test suite( ) {
TestSuite suite = new ActiveTestSuite( );
suite.addTest(new TestGame("testCreateFighter"));
suite.addTest(new TestGame("testGameInitialState"));
suite.addTest(new TestGame("testSameFighters"));
return suite;
}
While you probably won't use this technique often, running tests in threads can serve as a rudimentary
stress tester. You might also use ActiveTestSuite to help identify threading problems in your
code. By combining ActiveTestSuite with RepeatedTest, you can uncover threading
problems that only show up intermittently.
Example 4-7 shows how you can combine repeated tests and other test suites into an
ActiveTestSuite. Each of the repeated tests runs in a different thread; therefore, you end up
with four threads. If you are experiencing occasional threading glitches, you might want to increase
the number of iterations and run a similar test suite overnight.
Example 4-7. A more advanced test suite
public static Test suite( ) {
TestSuite suite = new ActiveTestSuite( );
// run one test in a thread
suite.addTest(new TestGame("testCreateFighter"));
// run this test 100 times in a second thread
suite.addTest(new RepeatedTest(
new TestGame("testGameInitialState"), 100));
// run this test 200 times in a third thread
suite.addTest(new RepeatedTest(
new TestGame("testSameFighters"), 200));
// run some other test suite in a fourth thread
suite.addTest(TestPerson.suite( ));
return suite;
}
4.14.4 See Also
Recipe 4.10 explains the RepeatedTest class.
4.15 Testing Asynchronous Methods
4.15.1 Problem
You want to test asynchronous methods.
4.15.2 Solution
Use a mock listener to wait for the asynchronous method to complete.
4.15.3 Discussion
An asynchronous method executes in its own thread, notifying some listener when it is complete.
Code that calls an asynchronous method does not block, meaning that you cannot write a test like this:
public void testSomething( ) {
someAsynchronousMethod( );
assertXXX(...);
}
The problem with this code lies in the fact that the assertXXX( ) is almost certainly executed
before the thread started by someAsynchronousMethod( ) has a chance to do its work. We
really need to do something like this:
1. Call an asynchronous method.
2. Wait until the method is complete.
3. Get the results.
• If the method times out, fail.
• Otherwise, check the results.
To illustrate, let's look at a simple interface for searching. We assume that searching occurs in its own
thread, notifying a SearchModelListener whenever the search is complete. Example 4-8
shows the API.
Example 4-8. SearchModel interface
public interface SearchModel {
void search(Object searchCriteria, SearchModelListener
listener);
}
The search( ) method is asynchronous, notifying the SearchModelListener when it is
complete. Example 4-9 shows the code for the SearchModelListener interface.
Example 4-9. SearchModelListener interface
public interface SearchModelListener extends EventListener {
void searchFinished(SearchModelEvent evt);
}
In order to test the search model, we must write a mock listener that waits for the search to complete.
Once the mock listener receives its result, we can verify that the data is correct. Example 4-10 shows
the code for a mock listener.
Example 4-10. MockSearchModelListener class
class MockSearchModelListener implements SearchModelListener {
private SearchModelEvent evt;
public void searchFinished(SearchModelEvent evt) {
this.evt = evt;
synchronized (this) {
notifyAll( );
}
}
public SearchModelEvent getSearchModelEvent( ) {
return this.evt;
}
}
The key to our mock listener is the synchronized block. This listener assumes that some other
thread (our unit test) is waiting for the search to complete. By calling notifyAll( ), the mock
listener allows the unit test to "wake up" and continue.[10] Example 4-11 shows the unit test, which ties
everything together.
[10] notifyAll() can only be called within synchronized code.
Example 4-11. Asynchronous unit test
public void testAsynchronousSearch( ) throws
InterruptedException {
MockSearchModelListener mockListener = new
MockSearchModelListener( );
SearchModel sm = new PersonSearchModel( );
// 1. Execute the search
sm.search("eric", mockListener);
// 2. Wait for the search to complete
synchronized (mockListener) {
mockListener.wait(2000);
}
// 3. Get the results
SearchModelEvent evt = mockListener.getSearchModelEvent(
);
// 3a) if the method times out, fail
assertNotNull("Search timed out", evt);
// 3b) otherwise, check the results
List results = evt.getSearchResult( );
assertEquals("Number of results", 1, results.size( ));
Person p = (Person) results.get(0);
assertEquals("Result", "Eric", p.getFirstName( ));
}
The unit test first creates a mock listener, passing that listener to the search model. It then uses a
synchronized block to wait until the listener calls notifyAll( ). Calling wait(2000)
indicates that the test will wait for at least two seconds before it stops waiting and continues. If this
happens, the mock listener's event object is null because it was never notified by the search model.
Having a timeout period is critical; otherwise, your test will wait indefinitely if
the asynchronous method fails and never notifies the caller.
Assuming the search completed within two seconds, the test goes on to check the results for
correctness.
4.15.4 See Also
Mock objects are described in Chapter 6.
4.16 Writing a Base Class for Your Tests
4.16.1 Problem
You want to reuse the same behavior in all of your tests without duplicating code.
4.16.2 Solution
Define common behavior in a subclass of junit.framework.TestCase and extend from
your class, rather than directly extending TestCase.
4.16.3 Discussion
JUnit does not require that your tests directly extend TestCase. Instead, you can introduce new
TestCase extensions for common behavior. You might want to ensure that some common
initialization code is always executed before each of your tests. In that case, you might write
something like this:
public abstract class MyAbstractTestCase extends TestCase {
public MyAbstractTestCase( ) {
initializeApplicationProperties( );
}
public MyAbstractTestCase(String testName) {
super(testName);
initializeApplicationProperties( );
}
// initialize some custom application framework. Leave
this method
// protected so subclasses can customize.
protected void initializeApplicationProperties( ) {
MyFramework.initialize("common/myappconfig.properties");
}
}
Tests in your application can now extend MyAbstractTestCase and your framework
initialization code will always be executed before the tests run.
Providing convenience methods is another reason why you might want to extend TestCase. We
show this in the next recipe when we define a method to retrieve a Swing JFrame for graphical
testing.
4.17 Testing Swing Code
4.17.1 Problem
You want to write unit tests for Swing portions of your application.
4.17.2 Solution
Keep application logic separate from GUI layout, thus minimizing the need to test graphical code
directly. Also, design your user interface in terms of discrete components that are testable without
complex setup and configuration.
4.17.3 Discussion
Graphical code presents many testing challenges. For instance, many Swing functions only work when
the components are visible on screen. In these cases, your tests have to create dummy frames and
show the components before the tests can succeed. In other cases, Swing schedules events on the
AWT event queue rather than updating component states immediately. We show how to tackle this
issue in the next recipe.
Ideally, you should strive to minimize the need to test Swing code in the first place. Application logic,
such as computing the monthly payment amount for a loan, should not be intertwined with the
JTable that displays the payment history. Instead, you might want to define three separate classes:
Loan
A utility class that keeps track of payments, interest rates, and other attributes. This class can
be tested independently of Swing.
LoanPaymentTableModel
A Swing table model for a history of loan payments. Because table models are nongraphical,
you can test them just like any other Java class.
JTable
Displays the LoanPaymentTableModel. Because JTable is provided with Swing,
you don't have to test it.
There are more complex scenarios where you cannot avoid Swing testing. Let's suppose you need a
panel to display information about a person and would like to test it. The Person class is easily
testable on its own, and probably contains methods to retrieve a name, address, SSN, and other key
pieces of information. But the PersonEditorPanel is graphical and a little more challenging to
test. You might start with the code shown in Example 4-12.
Example 4-12. First draft of PersonEditorPanel.java
public class PersonEditorPanel extends JPanel {
private JTextField firstNameField = new JTextField(20);
private JTextField lastNameField = new JTextField(20);
// @todo - add more fields later
private Person person;
public PersonEditorPanel( ) {
layoutGui( );
updateDataDisplay( );
}
public void setPerson(Person p) {
this.person = person;
updateDataDisplay( );
}
public Person getPerson( ) {
// @todo - update the person with new information from
the fields
return this.person;
}
private void layoutGui( ) {
// @todo - define the layout
}
private void updateDataDisplay( ) {
// @todo - ensure the fields are properly enabled,
also set
// data on the fields.
}
}
Our PersonEditorPanel does not function yet, but it is far enough along to begin writing unit
tests. Before delving into the actual tests, let's look at a base class for Swing tests. Example 4-13
shows a class that provides access to a JFrame for testing purposes. Our unit test for
PersonEditorPanel will extend from SwingTestCase.
Example 4-13. SwingTestCase.java
package com.oreilly.javaxp.junit;
import junit.framework.TestCase;
import javax.swing.*;
import java.lang.reflect.InvocationTargetException;
public class SwingTestCase extends TestCase {
private JFrame testFrame;
protected void tearDown( ) throws Exception {
if (this.testFrame != null) {
this.testFrame.dispose( );
this.testFrame = null;
}
}
public JFrame getTestFrame( ) {
if (this.testFrame == null) {
this.testFrame = new JFrame("Test");
}
return this.testFrame;
}
}
SwingTestCase provides access to a JFrame and takes care of disposing the frame in its
tearDown( ) method. As you write more Swing tests, you can place additional functionality in
SwingTestCase.
Example 4-14 shows the first few tests for PersonEditorPanel. In these tests, we check to see
if the fields in the panel are enabled and disabled properly.
Example 4-14. The first PersonEditorPanel tests
public class TestPersonEditorPanel extends SwingTestCase {
private PersonEditorPanel emptyPanel;
private PersonEditorPanel tannerPanel;
private Person tanner;
protected void setUp( ) throws Exception {
// create a panel without a Person
this.emptyPanel = new PersonEditorPanel( );
// create a panel with a Person
this.tanner = new Person("Tanner", "Burke");
this.tannerPanel = new PersonEditorPanel( );
this.tannerPanel.setPerson(this.tanner);
}
public void testTextFieldsAreInitiallyDisabled( ) {
assertTrue("First name field should be disabled",
!this.emptyPanel.getFirstNameField().isEnabled( ));
assertTrue("Last name field should be disabled",
!this.emptyPanel.getLastNameField().isEnabled(
));
}
public void testEnabledStateAfterSettingPerson( ) {
assertTrue("First name field should be enabled",
this.tannerPanel.getFirstNameField().isEnabled( ));
assertTrue("Last name field should be enabled",
this.tannerPanel.getLastNameField().isEnabled(
));
}
You might notice that our tests have to get to the first and last name fields, so we need to introduce the
getFirstNameField( ) and getLastNameField( ) methods in our panel:
JTextField getFirstNameField( ) {
return this.firstNameField;
}
JTextField getLastNameField( ) {
return this.lastNameField;
}
These methods are package-scope because we only need them for testing purposes. When you first run
the unit tests, they will fail because we did not write any logic to enable and disable the fields. This
method can be added to PersonEditorPanel in order to make the tests pass:
private void updateEnabledStates( ) {
this.firstNameField.setEnabled(person != null);
this.lastNameField.setEnabled(person != null);
}
Once you get these tests working, you can test for the actual values of the two fields:
public void testFirstName( ) {
assertEquals("First name", "",
this.emptyPanel.getFirstNameField().getText( ));
assertEquals("First name", this.tanner.getFirstName( ),
this.tannerPanel.getFirstNameField().getText( ));
}
public void testLastName( ) {
assertEquals("Last name", "",
this.emptyPanel.getLastNameField().getText( ));
assertEquals("Last name", this.tanner.getLastName( ),
this.tannerPanel.getLastNameField().getText( ));
}
These will also fail until you add some more logic to PersonEditorPanel to set data on the
two text fields:
private void updateDataDisplay( ) {
if (this.person == null) {
this.firstNameField.setText("");
this.lastNameField.setText("");
} else {
this.firstNameField.setText(this.person.getFirstName(
));
this.lastNameField.setText(this.person.getLastName(
));
}
updateEnabledStates( );
}
When complete, your tests should confirm that you can create an empty panel, set a person object on
it, and retrieve person object after it has been edited. You should also write tests for unusual
conditions, such as a null person reference or null data within the person. This is a data-oriented test,
ensuring that the panel properly displays and updates its data. We did not try to verify the graphical
positioning of the actual components, nor have we tried to test user interaction with the GUI.
4.17.4 See Also
Recipe 4.19 discusses problems with java.awt.Robot. Chapter 11 provides some references to
Swing-specific testing tools. Recipe 11.6 discusses some pros and cons of making methods packagescope
for the sole purpose of testing them.
4.18 Avoiding Swing Threading Problems
4.18.1 Problem
You want to test Swing functions that dispatch to the AWT event queue, such as focus traversal.
4.18.2 Solution
Write a utility method to wait until pending AWT event queue messages are processed.
4.18.3 Discussion
Suppose you want to test the focus traversal order of the PersonEditorPanel introduced in the
previous recipe. You want to ensure that focus travels from component to component in the correct
order as the user hits the tab key. To do this, you write the following test:
public void testTabOrder( ) {
JTextField firstNameField =
this.tannerPanel.getFirstNameField( );
firstNameField.requestFocusInWindow( );
// simulate the user hitting tab
firstNameField.transferFocus( );
// ensure that the last name field now has focus
JTextField lastNameField =
this.tannerPanel.getLastNameField( );
assertTrue("Expected last name field to have focus",
lastNameField.hasFocus( ));
}
As written, this test fails. First and foremost, the components must be visible on screen before they
can obtain focus. So you try modifying your setUp( ) method as follows:
protected void setUp( ) throws Exception {
this.emptyPanel = new PersonEditorPanel( );
this.tanner = new Person("Tanner", "Burke");
this.tannerPanel = new PersonEditorPanel( );
this.tannerPanel.setPerson(this.tanner);
getTestFrame().getContentPane( ).add(this.tannerPanel,
BorderLayout.CENTER);
getTestFrame().pack( );
getTestFrame().show( );
}
This takes advantage of the JFrame provided by our base class, SwingTestCase. When you
run your test again, it still fails! The initial focus never made it to the first name field. Here is a partial
solution:
public void testTabOrder( ) {
JTextField firstNameField =
this.tannerPanel.getFirstNameField( );
// make sure the first name field has focus
while (!firstNameField.hasFocus( )) {
getTestFrame().toFront( );
firstNameField.requestFocusInWindow( );
}
// simulate the user hitting tab
firstNameField.transferFocus( );
// ensure that the last name field now has focus
JTextField lastNameField =
this.tannerPanel.getLastNameField( );
assertTrue("Expected last name field to have focus",
lastNameField.hasFocus( ));
}
This approach keeps trying until the first name field eventually gains focus. It also brings the test
frame to the front of other windows because, during testing, we found that the frame sometimes gets
buried if the user clicks on any other window while the test is running. We discovered this by
repeating our tests and clicking on other applications while the tests ran:
public static Test suite( ) {
return new RepeatedTest(
new TestSuite(TestPersonEditorPanel.class), 1000);
}
We still have one more problem. When the test runs repeatedly, you will notice that the test fails
intermittently. This is because the transferFocus( ) method does not occur immediately.
Instead, the request to transfer focus is scheduled on the AWT event queue. In order to pass
consistently, the test must wait until the event has a chance to be processed by the queue. Example 4-
15 lists the final version of our test.
Example 4-15. Final tab order test
public void testTabOrder( ) {
JTextField firstNameField =
this.tannerPanel.getFirstNameField( );
// make sure the first name field has focus
while (!firstNameField.hasFocus( )) {
getTestFrame().toFront( );
firstNameField.requestFocusInWindow( );
}
// simulate the user hitting tab
firstNameField.transferFocus( );
// wait until the transferFocus( ) method is processed
waitForSwing( );
// ensure that the last name field now has focus
JTextField lastNameField =
this.tannerPanel.getLastNameField( );
assertTrue("Expected last name field to have focus",
lastNameField.hasFocus( ));
}
The waitForSwing( ) method is a new feature of our base class, SwingTestCase, that
blocks until pending AWT events like transferFocus( ) are processed:
public void waitForSwing( ) {
if (!SwingUtilities.isEventDispatchThread( )) {
try {
SwingUtilities.invokeAndWait(new Runnable( ) {
public void run( ) {
}
});
} catch (InterruptedException e) {
} catch (InvocationTargetException e) {
}
}
}
Now, our test runs almost 100% of the time. When repeating the test thousands of times, you can
make the test fail every once in a while by randomly clicking on other applications. This is because
you take away focus just before the test asks the last name field if it has focus. This sort of problem is
unavoidable, and illustrates one of the reasons why you should minimize your dependency on Swing
tests.
The most valuable lesson of this recipe is the technique of repeating your graphical tests many
thousands of times until all of the quirky Swing threading issues are resolved. Once your tests run as
consistently as possible, remove the repeated test. Also, while your tests are running, avoid clicking on
other running applications so you don't interfere with focus events.
4.18.4 See Also
Chapter 11 provides some references to Swing-specific testing tools.
4.19 Testing with the Robot
4.19.1 Problem
You want to simulate the user clicking on the mouse or typing with the keyboard using
java.awt.Robot.
4.19.2 Solution
We do not recommend this technique.
4.19.3 Discussion
java.awt.Robot allows Java applications to take command of native system input events, such
as moving the mouse pointer or simulating keystrokes. At first glance, this seems to be a great way to
test your GUIs. Your tests can do exactly what the user might do and then verify that your components
are displaying the correct information.
We have found that this approach is dangerous.
• Robot tests are very fragile, breaking any time the GUI layout changes.
• If the user moves the mouse while the tests are running, the Robot continues clicking,
sometimes on the wrong application.[11]
[11] One programmer reported that the Robot sent a partially completed email because it clicked on
the send button of the mail client instead of a button in the application being tested.
• Since the tests run so quickly, it can be impossible to stop the tests once the Robot gets
confused and starts clicking on other apps and typing characters that show up in other
windows.
If you really feel that you could use some Robot tests, consider naming them differently than other
tests. You might have a collection of RobotTest*.java tests. You can then run them independently of
other tests, if you are extremely careful to avoid touching the mouse while the tests run.
4.19.4 See Also
Chapter 11 provides some references to Swing-specific testing tools.
4.20 Testing Database Logic
4.20.1 Problem
You want to test database logic using JUnit.
4.20.2 Solution
Write scripts to generate a stable testing database and test against that data.
4.20.3 Discussion
Testing against a database is challenging in many organizations because you have to define
predictable data.[12] The only truly reliable approach is to create the test data in a private database
automatically for each set of tests. When the tests are finished, you should destroy the test data. If you
create the test database manually, you run the risk of corruption over time as people modify data that
your tests assume is present.
[12] This is a political battle in many companies, because the database administrators might not give
programmers the permission to create new tables or perform other functions necessary to create test data.
For very large databases, you may have to settle for either creating clean test
data daily or weekly, or loading a subset of the database with well-known
testing records.
We recommend that you follow the technique outlined in Recipe 4.7 to perform one-time setup and
tear down before and after a group of tests. You can create the test data in the one-time setup, and
remove it in the one-time tear down. Once you have control of the data, you can test against that data:
public void testDeleteEmployee( ) throws SQLException {
EmployeeDAO dao = new EmployeeDAO( );
assertNotNull("Employee 'ericBurke' should be present",
dao.getEmployee("ericBurke"));
dao.deleteEmployee("ericBurke");
assertNull("Employee 'ericBurke' should not be present",
dao.getEmployee("ericBurke"));
}
Another challenge is the fact that early tests might modify data in ways that interfere with later tests.
In these cases, you can either write functions to clean up data after the earlier tests run, or you can
build your test suites manually. By building the suites manually, you can control the order in which
the tests run:
public static Test suite( ) {
TestSuite suite = new TestSuite( );
suite.addTest(new TestEmployeeDB("testCreateEmployee"));
suite.addTest(new TestEmployeeDB("testUpdateEmployee"));
suite.addTest(new TestEmployeeDB("testDeleteEmployee"));
return suite;
}
Database-specific copy, backup, and restore mechanisms are sometimes
tremendously faster than reinitializing the database with a series of SQL
statements. For example, if your database is MS SQL Server, you can copy
over a known testing database .mdf/.ldf file to get your database to a known
state very quickly.
4.20.4 See Also
Recipe 4.7 shows how to implement oneTimeSetUp( ) and oneTimeTearDown( ).
4.21 Repeatedly Testing the Same Method
4.21.1 Problem
You want to test a method with a wide range of input data. You are not sure if you should write a
different test for each combination of input data, or one huge test that checks every possible
combination.
4.21.2 Solution
Write a suite( ) method that iterates through all of your input data, creating a unique instance of
your test case for each unique input. The data is passed to the test cases through the constructor, which
stores the data in instance fields so it is available to the test methods.
4.21.3 Discussion
You often want to test some piece of functionality with many different combinations of input data.
Your first impulse might be to write a different test method for each possible combination of data;
however, this is tedious and results in a lot of mundane coding. A second option is to write a single,
big test method that checks every possible combination of input data. For example:
public void testSomething( ) {
Foo foo = new Foo( );
// test every possible combination of input data
assertTrue(foo.doSomething(false, false, false);
assertFalse(foo.doSomething(false, false, true);
assertFalse(foo.doSomething(false, true, false);
assertTrue(foo.doSomething(false, true, true);
...etc
}
This approach suffers from a fatal flaw. The problem is that the test stops executing as soon as the first
assertion fails, so you won't see all of the errors at once. Ideally, you want to easily set up a large
number of test cases and run them all as independent tests. One failure should not prevent the
remaining tests from running.
To illustrate this technique, Example 4-16 contains a utility for determining the background color of a
component. The getFieldBackground( ) method calculates a different background color
based on numerous parameters—for example, whether a record is available and whether the current
data is valid.
Example 4-16. UtilComponent
public class UtilComponent {
public static final int ADD_MODE = 1;
public static final int RECORD_AVAILABLE_MODE = 2;
public static final int NO_RECORD_AVAILABLE_MODE = 3;
public static final int KEY_FIELD = 100;
public static final int REQUIRED_FIELD = 101;
public static final int READONLY_FIELD = 102;
public static final int NORMAL_FIELD = 103;
public static final Color FIELD_NORMAL_BACKGROUND =
Color.WHITE;
public static final Color FIELD_ERROR_BACKGROUND =
Color.PINK;
public static final Color FIELD_REQUIRED_BACKGROUND =
Color.CYAN;
public static final Color FIELD_DISABLED_BACKGROUND =
Color.GRAY;
public static Color getFieldBackground(
int screenMode,
int fieldType,
boolean valid,
boolean requiredConditionMet) {
if (fieldType == READONLY_FIELD
|| screenMode == NO_RECORD_AVAILABLE_MODE
|| (fieldType == KEY_FIELD && screenMode !=
ADD_MODE)) {
return FIELD_DISABLED_BACKGROUND;
}
if (!valid) {
return FIELD_ERROR_BACKGROUND;
}
if ((fieldType == KEY_FIELD || fieldType ==
REQUIRED_FIELD)
&& !requiredConditionMet) {
return FIELD_REQUIRED_BACKGROUND;
}
return FIELD_NORMAL_BACKGROUND;
}
public static String colorToString(Color color) {
if (color == null) {
return "null";
}
if (color.equals(FIELD_DISABLED_BACKGROUND)) {
return "FIELD_DISABLED_BACKGROUND";
}
if (color.equals(FIELD_ERROR_BACKGROUND)) {
return "FIELD_ERROR_BACKGROUND";
}
if (color.equals(FIELD_REQUIRED_BACKGROUND)) {
return "FIELD_REQUIRED_BACKGROUND";
}
if (color.equals(FIELD_NORMAL_BACKGROUND)) {
return "FIELD_NORMAL_BACKGROUND";
}
return color.toString( );
}
}
There are 48 possible combinations of inputs to the getFieldBackground( ) method, and 4
possible return values. The test case defines a helper class that encapsulates one combination of inputs
along with an expected result. It then builds an array of 48 instances of this class, 1 per combination of
input data. Example 4-17 shows this portion of our test.
Example 4-17. Defining the test data
public class TestUtilComponent extends TestCase {
private int testNumber;
static class TestData {
int screenMode;
int fieldType;
boolean valid;
boolean requiredConditionMet;
Color expectedColor;
public TestData(int screenMode, int fieldType, boolean
valid,
boolean requiredConditionMet, Color
expectedColor) {
this.screenMode = screenMode;
this.fieldType = fieldType;
this.valid = valid;
this.requiredConditionMet = requiredConditionMet;
this.expectedColor = expectedColor;
}
}
private static final TestData[] TESTS = new TestData[] {
new TestData(UtilComponent.ADD_MODE, // 0
UtilComponent.KEY_FIELD,
false, false,
UtilComponent.FIELD_ERROR_BACKGROUND),
new TestData(UtilComponent.ADD_MODE, // 1
UtilComponent.KEY_FIELD,
false, true,
UtilComponent.FIELD_ERROR_BACKGROUND),
new TestData(UtilComponent.ADD_MODE, // 2
UtilComponent.KEY_FIELD,
true, false,
UtilComponent.FIELD_REQUIRED_BACKGROUND),
...continue defining TestData for every possible input
The test extends from the normal JUnit TestCase base class, and defines a single private field
called testNumber. This field keeps track of which instance of TestData to test. Remember
that for each unit test, a new instance of TestUtilComponent is created. Thus, each instance
has its own copy of the testNumber field, which contains an index into the TESTS array.
The TESTS array contains every possible combination of TestData. As you can see, we include
comments containing the index in the array:
new TestData(UtilComponent.ADD_MODE, // 0
This index allows us to track down which test cases are not working when we encounter failures.
Example 4-18 shows the remainder of our test case, illustrating how the tests are executed.
Example 4-18. Remainder of TestUtilComponent
public TestUtilComponent(String testMethodName, int
testNumber) {
super(testMethodName);
this.testNumber = testNumber;
}
public void testFieldBackgroundColor( ) {
TestData td = TESTS[this.testNumber];
Color actualColor =
UtilComponent.getFieldBackground(td.screenMode,
td.fieldType, td.valid,
td.requiredConditionMet);
assertEquals("Test number " + this.testNumber + ": ",
UtilComponent.colorToString(td.expectedColor),
UtilComponent.colorToString(actualColor));
}
public static Test suite( ) {
TestSuite suite = new TestSuite( );
for (int i=0; i<TESTS.length; i++) {
suite.addTest(new
TestUtilComponent("testFieldBackgroundColor", i));
}
return suite;
}
}
Our constructor does not follow the usual JUnit pattern. In addition to the test method name, we
accept the test number. This is assigned to the testNumber field, and indicates which data to test.
The testFieldBackgroundColor( ) method is our actual unit test. It uses the correct
TestData object to run UtilComponent.getFieldBackground( ), using
assertEquals( ) to check the color. We also use UtilComponent to convert the color to
a text string before doing the comparison. Although this is not required, it results in much more
readable error messages when the test fails.
The final portion of our test is the suite( ) method. JUnit uses reflection to search for this
method. If found, JUnit runs the tests returned from suite( ) rather than using reflection to locate
testXXX( ) methods. In our case, we loop through our array of test data, creating a new instance
of TestUtilComponent for each entry. Each test instance has a different test number, and is
added to the TestSuite. This is how we create 48 different tests from our array of test data.
Although we have a hardcoded array of test data, there are other instances where you want to make
your tests more customizable. In those cases, you should use the same technique outlined in this
recipe. Instead of hardcoding the test data, however, you can put your test data into an XML file. Your
suite( ) method would parse the XML file and then create a TestSuite containing the test
data defined in your XML.
4.21.4 See Also
Recipe 4.6 explains how JUnit normally instantiates and runs test cases.
Chapter 5. HttpUnit
Section 5.1. Introduction
Section 5.2. Installing HttpUnit
Section 5.3. Preparing for Test-First Development
Section 5.4. Checking a Static Web Page
Section 5.5. Following Hyperlinks
Section 5.6. Writing Testable HTML
Section 5.7. Testing HTML Tables
Section 5.8. Testing a Form Tag and Refactoring Your Tests
Section 5.9. Testing for Elements on HTML Forms
Section 5.10. Submitting Form Data
Section 5.11. Testing Through a Firewall
Section 5.12. Testing Cookies
Section 5.13. Testing Secure Pages
5.1 Introduction
HttpUnit, available from http://www.httpunit.org, is an open source Java library for programmatically
interacting with HTTP servers. With HttpUnit, your Java programs can access servers directly,
without the need for a browser. HttpUnit provides an API for parsing HTML, submitting forms,
following hyperlinks, setting cookies, and performing many other tasks normally associated with web
browsers. It also includes a class library for direct manipulation of servlets, sometimes bypassing the
need to start a web server.
Despite its name, HttpUnit is not a testing tool. Instead, it provides an API for interacting with HTML
and HTTP servers. You normally think of HttpUnit as a testing tool, however, because you use
HttpUnit in conjunction with JUnit to write tests. JUnit defines the testing framework and your
testXXX( ) methods use the HttpUnit API to access and test web pages.
Tests written with HttpUnit are usually more like "integration" tests than "unit"
tests. A unit test normally tests a single method or class in isolation, while
HttpUnit tests invoke HTTP servers across a network connection.
Using HttpUnit in combination with JUnit is the focus of the recipes in this chapter. The recipes are
presented in order as portions of a simple web application developed using a test-first approach. If the
web application were complete, it would allow users to subscribe and unsubscribe from a newsletter.
It would also allow administrators to view the complete list of newsletter subscribers, but only after
providing a username and password.
HttpUnit cannot test JavaScript. You might consider JsUnit, available at
http://sourceforge.net/projects/jsunit/.
5.2 Installing HttpUnit
5.2.1 Problem
You want to install HttpUnit.
5.2.2 Solution
Add httpunit.jar and Tidy.jar, both included with HttpUnit, to your classpath. Also ensure that an
XML parser is installed.
5.2.3 Discussion
httpunit.jar contains the class files for the HttpUnit application. Its API allows you to send requests to
web servers, obtain responses, and test the content of the resulting web pages. It also contains the
com.meterware.servletunit package for testing servlets directly, without going through a
web server.
Tidy.jar, also included in the HttpUnit distribution, contains the Java port of HTML Tidy, an open
source tool for checking the syntax of HTML. HTML Tidy also includes an API for parsing HTML,
which is the part used by HttpUnit. You can learn more about the Java port of HTML Tidy at
http://sourceforge.net/projects/jtidy.
If you are running under JDK 1.4, add httpunit.jar and Tidy.jar to your classpath. If you are running
an older version of Java, you must also include a JAXP-compliant XML parser in your classpath. The
next recipe shows how to do this.
5.2.4 See Also
Recipe 5.3 shows how to configure HttpUnit with Ant.
5.3 Preparing for Test-First Development
5.3.1 Problem
You want to configure your development environment to support test-first development with
HttpUnit, JUnit, Tomcat, and Ant.
5.3.2 Solution
Create an Ant buildfile to automatically build and deploy your web application. The buildfile allows
you to quickly redeploy and test after each change to your code.
5.3.3 Discussion
The example shown in this recipe relies on Tomcat 4.0 or later, as well as Ant Version 1.5. It uses
Tomcat's manager application to deploy and redeploy the web application while Tomcat is running.
The ability to redeploy a modified web application while the server is running is critical for test-first
development because it takes too long to restart most servers. A successful XP approach depends on
your ability to make lots of small code changes quickly.
In order to test using Ant's junit task, you should copy servlet.jar, httpunit.jar, junit.jar, and
Tidy.jar to Ant's lib directory. This makes it easy to ensure that all of the required JAR files are loaded
using the same Java ClassLoader when you are running your tests. Ant class loading issues were
discussed in Recipe 3.15.
The first part of your buildfile should define a classpath:
<path id="classpath.project">
<pathelement path="${dir.build}"/>
</path>
This path picks up all class files from your build directory. Ant also includes all of the JAR files from
the ANT_HOME/lib directory. This allows you to compile the code with this target:
<target name="compile" depends="prepare"
description="Compile all source code.">
<javac srcdir="${dir.src}" destdir="${dir.build}">
<classpath refid="classpath.project"/>
</javac>
</target>
And next, your buildfile should have a target to generate the WAR file:
<target name="war" depends="compile">
<!-- build the newsletter example from the HttpUnit chapter
-->
<war warfile="${dir.build}/news.war"
webxml="httpunit_chapter/web.xml">
<fileset dir="httpunit_chapter">
<exclude name="web.xml"/>
</fileset>
<classes dir="${dir.build}">
<include name="com/oreilly/javaxp/httpunit/**/*.class"/>
</classes>
</war>
</target>
This target assumes that your development environment has a directory named httpunit_chapter
containing any HTML files comprising your web application. The deployment descriptor, web.xml, is
also found in this directory. Finally, the <classes> element specifies where to find the .class files
for the web application. Although your environment will likely be quite different, you will want
targets similar to this in order to quickly generate your own WAR file.
Once you have figured out how to generate your WAR file, turn your attention to deployment.
Tomcat's manager application uses an HTTP interface for its functionality. To deploy, use the
following command:
http://localhost:8080/manager/install?path=/news&war=jar:file:
/path/to/news.war!/
If you need to redeploy, you must first undeploy the application. Here is the command to undeploy the
application:
http://localhost:8080/manager/remove?path=/news
The manager application fails unless you first configure a username and password, so you must edit
the tomcat-users.xml file in Tomcat's conf directory. Simply add a user with the manager role:
<tomcat-users>
<!-- add this user to access the manager application -->
<user name="eric" password="secret" roles="manager" />
<user name="tomcat" password="tomcat" roles="tomcat" />
<user name="role1" password="tomcat" roles="role1" />
<user name="both" password="tomcat" roles="tomcat,role1"
/>
</tomcat-users>
We are almost finished! Now that the user is configured and you know how to run the manager
application, you can write some Ant targets to deploy and undeploy the application.
This example requires Ant Version 1.5 or later because prior to Ant 1.5, there was no standard way to
pass the required username and password to a web server from an Ant task. Ant 1.5 adds HTTP
BASIC authentication support to its get task, thus supporting the username and password.
The following code example shows how to use Ant's get task to undeploy and deploy a web
application to Tomcat.
<target name="undeploy">
<!-- use the manager app to undeploy -->
<get src="${url.manager}/remove?path=/news"
dest="${dir.build}/undeployOutput.txt"
username="eric"
password="secret"
verbose="true"/>
<!-- the manager app does not delete the directory for us --
>
<delete dir="${env.TOMCAT_HOME}/webapps/news"/>
<!-- echo the results to the console -->
<!-- NOTE: This reports an error when you first run it,
because the app is not initially deployed -->
<concat>
<filelist dir="${dir.build}" files="undeployOutput.txt" />
</concat>
</target>
<target name="deploy" depends="war,undeploy">
<!--
Convert the project-relative path, such as
"build/news.war",
into a fully-qualitifed path like
"C:/dev/news/build/news.war"
-->
<pathconvert dirsep="/" property="fullWarDir">
<path>
<pathelement location="${dir.build}/news.war"/>
</path>
</pathconvert>
<!-- Use the manager app to deploy -->
<get src="${url.manager}/install
?path=/news&amp;war=jar:file:${fullWarDir}!/"
dest="${dir.build}/deployOutput.txt"
username="eric"
password="secret"
verbose="true"/>
<!-- echo the results to the console -->
<concat>
<filelist dir="${dir.build}" files="deployOutput.txt" />
</concat>
</target>
For the icing on the cake, you should define a target that executes your unit tests.
<target name="junit" depends="deploy">
<junit printsummary="on" fork="false"
haltonfailure="false">
<classpath refid="classpath.project"/>
<formatter type="plain"/>
<batchtest fork="false" todir="${dir.build}">
<fileset dir="${dir.src}">
<include name="**/Test*.java"/>
<exclude name="**/AllTests.java"/>
</fileset>
</batchtest>
</junit>
</target>
Notice the dependencies. When you type ant junit, the deploy target is executed. This, in
turn, causes the WAR file to be built, which causes the code to be compiled.
Setting up an efficient development environment is well worth the effort. After you write each new
unit test and small piece of functionality, you can type ant junit to compile, build the WAR file,
deploy, and run all tests.
5.3.4 See Also
Recipe 3.15 discusses Ant class loading issues. Chapter 10 contains a much more sophisticated
buildfile that handles all sorts of deployment and server startup issues.
5.4 Checking a Static Web Page
5.4.1 Problem
You want to test for the existence of a static web page.
5.4.2 Solution
Write a JUnit test fixture, and then use classes in the com.meterware.httpunit package to
connect to the web page.
5.4.3 Discussion
When starting a brand new web application, verify that you can connect to the home page before
doing anything else. This is the simplest test that you can write, and only takes a few lines of code.
Example 5-1 shows how to do it.
Example 5-1. Testing for a static web page
package com.oreilly.javaxp.httpunit;
import com.meterware.httpunit.*;
import junit.framework.TestCase;
public class TestNewsletter extends TestCase {
public TestNewsletter(String name) {
super(name);
}
public void testIndexPageExists( ) throws Exception {
WebConversation webConversation = new WebConversation(
);
WebRequest request =
new
GetMethodWebRequest("http://localhost:8080/news");
WebResponse response =
webConversation.getResponse(request);
}
}
The WebConversation class is described as HttpUnit's replacement for the web browser.
WebConversation is the client, allowing you to send requests and obtain responses from a web
server.
Use the GetMethodWebRequest class to issue an HTTP GET request, specifying a URL in the
constructor. This mimics a user typing in a URL in their web browser. Then call the
getResponse( ) method to actually issue the request and retrieve the web page. If
getResponse( ) cannot find the web page, it throws a new instance of
HttpNotFoundException. As customary in JUnit, you should not catch this exception.
Instead, let the JUnit framework catch the exception and treat it as a test error.
Since requesting a page is such a common operation, HttpUnit offers a simplified syntax that achieves
the same results:
WebConversation webConversation = new WebConversation( );
WebResponse response =
webConversation.getResponse("http://localhost:8080/news");
We do not care about the content of the response. Instead, we are merely checking for the existence of
the home page. Because of this, we can simplify the example even further. First, we get rid of the
response object because we never refer to it:
WebConversation webConversation = new WebConversation( );
webConversation.getResponse("http://localhost:8080/news");
And finally, we can inline the code into a single statement. In this case, we feel that inlining makes the
code easier to read, particularly because the name of our test method explains what we are trying to
test. Clarity is almost always more important than brevity, so you should avoid inlining if it makes the
code harder to understand. Here is the final unit test:
public void testIndexPageExists( ) throws Exception {
// this throws HttpNotFoundException if the home page is
not found
new WebConversation(
).getResponse("http://localhost:8080/news");
}
If you set up your Ant buildfile and Tomcat as explained in Recipe 5.3, you can type ant junit to
run this test.
5.4.4 See Also
Recipe 5.3 shows how to set up the build environment. Recipe 4.13 shows how to handle exceptions
using JUnit.
5.5 Following Hyperlinks
5.5.1 Problem
You want to obtain hyperlinks, simulate clicking on them, and test that the correct response is
returned.
5.5.2 Solution
Use the WebResponse.getLinkWith( ) method to obtain a WebLink object, then call
WebLink.getRequest( ) to get a new WebRequest that you can execute. Executing this
second request simulates the user clicking on the link.
5.5.3 Discussion
The HTTP protocol is a series of requests and responses. Following a hyperlink is merely a case of
issuing an HTTP GET request and checking the response. As you are adding new links to your web
application, you should attempt to write a test first. The first time you run the test, it fails because the
link does not exist. Here is a test that obtains a hyperlink and then attempts to follow it:
public void testFollowLinkToSubscriptionPage( ) throws
Exception {
// get the home page
WebConversation webConversation = new WebConversation( );
WebResponse response = webConversation.getResponse(
"http://localhost:8080/news");
WebLink subscriptionLink =
response.getLinkWith("subscription");
// get a request to simulate clicking on the link
WebRequest clickRequest = subscriptionLink.getRequest( );
// throws HttpNotFoundException if the link is broken
WebResponse subscriptionPage =
webConversation.getResponse(clickRequest);
}
The WebResponse.getLinkWith( ) method searches for the first hyperlink in the web
page that contains some piece of text. In our example, we are searching for a link like this:
<a href="someUrl">subscription</a>
This illustrates how HttpUnit uses the JTidy library to parse the HTML. You call the
getLinkWith( ) convenience method, and HttpUnit uses JTidy to search the DOM tree for the
first matching hyperlink. If one is not found, the WebLink object will be null.
Once you have the WebLink object, you get a new WebRequest and ask it for a new
WebResponse:
// get a request to simulate clicking on the link
WebRequest clickRequest = subscriptionLink.getRequest( );
// throws HttpNotFoundException if the link is broken
WebResponse subscriptionPage =
webConversation.getResponse(clickRequest);
If you are following a test-first approach, the link will not be valid. It is a good idea to run the faulty
test first, just to prove to yourself that your test catches the problem should the link actually fail
sometime in the future. Now you can write your servlet to generate the subscription page:
public class NewsletterServlet extends HttpServlet {
protected void doGet(HttpServletRequest req,
HttpServletResponse res)
throws ServletException, IOException {
res.setContentType("text/html");
PrintWriter pw = res.getWriter( );
pw.println("<html>");
pw.println("<body>");
pw.println("<h1>NewsletterServlet</h1>");
pw.println("</body>");
pw.println("</html>");
}
}
Notice how, in the test-first approach, you don't write the complete servlet. Instead, you create a
stubbed-out page that generates a minimal response. You can now run your test suite again, and
should see that the link is valid and the test passes. This is also a good time to go back to your web
browser and bring up the web page and try out the hyperlink interactively.